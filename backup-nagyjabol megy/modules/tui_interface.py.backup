"""
Enhanced TUI Interface for Windows Services Management
Full-featured interface matching original kopf-urwid-controller.py functionality
with consolidated VMs/Services view
"""

import urwid
import logging
import queue
import time
from datetime import datetime

# Import from utils with fallback
try:
    from .utils.logging_config import log_queue
except ImportError:
    try:
        from utils.logging_config import log_queue
    except ImportError:
        import queue as queue_module
        log_queue = queue_module.Queue()

logger = logging.getLogger(__name__)

class WindowsServicesTUI:
    """Enhanced TUI interface with full functionality"""
    
    def __init__(self, service_manager):
        self.service_manager = service_manager
        self.log_lines = []
        self.max_log_lines = 500
        self.status_data = {}
        self.last_status_update = 0
        self.update_interval = 5
        self.auto_scroll = True
        self.active_service_tab = 'vms'  # vms, mssql, otel
        
        # Menu state management for hierarchical navigation
        self.menu_state = None  # None, 'install_method_selection', 'uninstall_method_selection', 'service_selection'
        self.pending_action = None  # 'install', 'uninstall', 'apply', 'delete'
        self.selected_method = None  # 'kubectl', 'ansible', 'manual'
        self.popup_listbox = None  # For popup navigation
        self.popup = None  # For popup management
        self.popup_callback = None  # For popup callbacks
        
        # Enhanced color palette matching original
        self.palette = [
            ('header', 'white', 'dark blue'),
            ('menu', 'black', 'light gray'),
            ('menu_focus', 'white', 'dark red'),
            ('log_info', 'light green', 'black'),
            ('log_error', 'light red', 'black'),
            ('log_warning', 'yellow', 'black'),
            ('footer', 'white', 'dark blue'),
            ('button', 'black', 'light gray'),
            ('button_focus', 'white', 'dark red'),
            ('status_running', 'light green', 'black'),
            ('status_stopped', 'light red', 'black'),
            ('status_unknown', 'yellow', 'black'),
            ('cr_deployed', 'light cyan', 'black'),
            ('cr_local', 'light magenta', 'black'),
            ('cr_missing', 'dark gray', 'black'),
            ('service_vm', 'light cyan', 'black'),
            ('service_mssql', 'light blue', 'black'),
            ('service_otel', 'light green', 'black'),
        ]
        
        self.setup_ui()
    
    def setup_ui(self):
        """Set up the enhanced user interface"""
        # Header
        header = urwid.Text(('header', 'Windows Services Management Console - Enhanced Modular System'), align='center')
        header = urwid.AttrMap(header, 'header')
        
        # Menu bar with action-focused functions
        menu_items = [
            ('Install', self.install_menu),
            ('Uninstall', self.uninstall_menu),
            ('Apply CRs', self.apply_cr_menu),
            ('Delete CR', self.delete_cr_menu),
            ('Fix Issues', self.fix_issues),
            ('Clear Logs', self.clear_logs),
            ('Quit', self.quit_app)
        ]
        
        menu_buttons = []
        for label, callback in menu_items:
            btn = urwid.Button(label, on_press=callback)
            btn = urwid.AttrMap(btn, 'menu', 'menu_focus')
            menu_buttons.append(btn)
        
        menu_bar = urwid.Columns(menu_buttons, dividechars=1)
        menu_frame = urwid.AttrMap(menu_bar, 'menu')
        
        # Separator line under menu
        separator = urwid.Divider('‚îÄ')
        separator = urwid.AttrMap(separator, 'menu')
        
        # Status display panel - consolidated VMs/Services view
        self.status_walker = urwid.SimpleFocusListWalker([])
        self.status_listbox = urwid.ListBox(self.status_walker)
        self.status_frame = urwid.LineBox(self.status_listbox, title="VMs & Services Status Overview")
        
        # Log display
        self.log_walker = urwid.SimpleFocusListWalker([])
        self.log_listbox = urwid.ListBox(self.log_walker)
        self.log_frame = urwid.LineBox(self.log_listbox, title="System Logs [FOCUSED]")
        
        # Create horizontal split - VMs/Services split as requested
        self.content_columns = urwid.Columns([
            ('weight', 1, self.status_frame),
            ('weight', 2, self.log_frame)
        ], dividechars=1, focus_column=1)
        
        # Footer with streamlined navigation instructions
        footer_text = "F2:Status F6:Install F7:Apply F8:AutoScroll F9:Reset Tab:Switch ‚Üê‚Üí:Navigate Q:Quit ESC:Cancel"
        footer = urwid.Text(('footer', footer_text), align='center')
        footer = urwid.AttrMap(footer, 'footer')
        
        # Main layout
        top_section = urwid.Pile([
            ('pack', header),
            ('pack', urwid.Text("")),
            ('pack', menu_frame),
            ('pack', separator),
            ('pack', urwid.Text("")),
        ])
        
        main_pile = urwid.Pile([
            ('pack', top_section),
            ('weight', 1, self.content_columns),
            ('pack', footer)
        ])
        
        self.main_frame = main_pile
    
    def show_vms_tab(self, button=None):
        """Switch to VMs view in status display"""
        self.active_service_tab = 'vms'
        self.status_frame.set_title("Windows VMs Status")
        self.update_status_display()
        if button:  # Only log if called via button/menu
            self.add_log_line("üìä Switched to Windows VMs view")
    
    def show_mssql_tab(self, button=None):
        """Switch to MSSQL services view in status display"""
        self.active_service_tab = 'mssql'
        self.status_frame.set_title("MSSQL Services Status")
        self.update_status_display()
        if button:  # Only log if called via button/menu
            self.add_log_line("üóÑÔ∏è Switched to MSSQL Services view")
    
    def show_otel_tab(self, button=None):
        """Switch to OpenTelemetry view in status display"""
        self.active_service_tab = 'otel'
        self.status_frame.set_title("OpenTelemetry Collectors Status")
        self.update_status_display()
        if button:  # Only log if called via button/menu
            self.add_log_line("üìä Switched to OpenTelemetry view")
    
    def update_status_display(self):
        """Update the consolidated status display"""
        try:
            current_time = time.time()
            
            # Throttle updates
            if current_time - self.last_status_update < self.update_interval:
                return
            
            self.last_status_update = current_time
            
            # Get comprehensive status from service manager
            status_report = self.service_manager.get_comprehensive_status()
            
            # Clear existing status display
            self.status_walker.clear()
            
            # Add header with timestamp
            timestamp = datetime.now().strftime("%H:%M:%S")
            if self.active_service_tab == 'vms':
                header_text = f'üñ•Ô∏è WINDOWS VMs STATUS ({timestamp})'
                self.update_vm_status_display(status_report)
            elif self.active_service_tab == 'mssql':
                header_text = f'üóÑÔ∏è MSSQL SERVICES STATUS ({timestamp})'
                self.update_mssql_status_display(status_report)
            elif self.active_service_tab == 'otel':
                header_text = f'üìä OPENTELEMETRY STATUS ({timestamp})'
                self.update_otel_status_display(status_report)
            
            # Insert header at top
            self.status_walker.insert(0, urwid.Text(('header', f'=== {header_text} ===')))
            self.status_walker.insert(1, urwid.Text(""))
            
            # Store status data for other methods
            self.status_data = status_report
            
        except Exception as e:
            self.status_walker.clear()
            self.status_walker.append(urwid.Text(('log_error', f'Error updating status: {e}')))
    
    def update_vm_status_display(self, status_report):
        """Update VM status display with scenarios"""
        # VM scenarios
        scenarios = status_report.get('scenarios', {})
        if scenarios:
            self.status_walker.append(urwid.Text(('service_vm', 'üìä VM SCENARIO ANALYSIS:')))
            for vm_name, scenario_data in scenarios.items():
                scenario = scenario_data['scenario']
                
                # Color coding based on scenario
                if 'Running' in scenario and 'Managed' in scenario:
                    color = 'status_running'
                    icon = '‚úÖ'
                elif 'Running' in scenario and 'Orphaned' in scenario:
                    color = 'status_unknown'
                    icon = '‚ö†Ô∏è'
                elif 'No Instance' in scenario:
                    color = 'status_stopped'
                    icon = '‚ùå'
                else:
                    color = 'status_unknown'
                    icon = '‚ùì'
                
                status_line = f"{icon} {vm_name}: {scenario}"
                self.status_walker.append(urwid.Text((color, status_line)))
                
                # Add details
                if scenario_data.get('local_cr'):
                    self.status_walker.append(urwid.Text(('cr_local', f"   üìÅ Local CR: {scenario_data['local_cr']} (action: {scenario_data.get('local_cr_action', 'unknown')})")))
                if scenario_data.get('deployed_cr'):
                    self.status_walker.append(urwid.Text(('cr_deployed', f"   ‚ò∏Ô∏è Deployed CR: {scenario_data['deployed_cr']} (action: {scenario_data.get('deployed_cr_action', 'unknown')})")))
                if scenario_data.get('vm_running'):
                    self.status_walker.append(urwid.Text(('status_running', f"   üñ•Ô∏è VM Status: {scenario_data.get('vm_status', 'unknown')}")))
                
                self.status_walker.append(urwid.Text(""))
        else:
            self.status_walker.append(urwid.Text(('status_unknown', '‚ùì No VMs found')))
        
        # Summary statistics
        windowsvm_summary = status_report.get('summary', {}).get('windowsvm', {})
        self.status_walker.append(urwid.Text(('header', 'üìà VM SUMMARY:')))
        self.status_walker.append(urwid.Text(f"Local CRs: {windowsvm_summary.get('local_count', 0)}"))
        self.status_walker.append(urwid.Text(f"Deployed CRs: {windowsvm_summary.get('deployed_count', 0)}"))
        self.status_walker.append(urwid.Text(f"Running VMs: {windowsvm_summary.get('running_count', 0)}"))
    
    def update_mssql_status_display(self, status_report):
        """Update MSSQL services status display"""
        mssql_data = status_report.get('mssqlservers', {})
        
        # Local CRs
        if mssql_data.get('local_crs'):
            self.status_walker.append(urwid.Text(('service_mssql', 'üìÅ LOCAL MSSQL CRs:')))
            for name, cr_data in mssql_data['local_crs'].items():
                target_vm = cr_data.get('target_vm', 'unknown')
                version = cr_data.get('version', 'unknown')
                enabled = cr_data.get('enabled', True)
                status_icon = '‚úÖ' if enabled else '‚è∏Ô∏è'
                self.status_walker.append(urwid.Text(('cr_local', f"  {status_icon} {name}: target={target_vm}, version={version}")))
            self.status_walker.append(urwid.Text(""))
        
        # Deployed CRs
        if mssql_data.get('deployed_crs'):
            self.status_walker.append(urwid.Text(('service_mssql', '‚ò∏Ô∏è DEPLOYED MSSQL CRs:')))
            for name, cr_data in mssql_data['deployed_crs'].items():
                target_vm = cr_data.get('target_vm', 'unknown')
                version = cr_data.get('version', 'unknown')
                status = cr_data.get('status', {}).get('phase', 'Unknown')
                
                if status == 'Ready':
                    color = 'status_running'
                    icon = 'üü¢'
                elif status == 'Failed':
                    color = 'status_stopped'
                    icon = 'üî¥'
                else:
                    color = 'status_unknown'
                    icon = 'üü°'
                
                self.status_walker.append(urwid.Text((color, f"  {icon} {name}: target={target_vm}, version={version}, status={status}")))
            self.status_walker.append(urwid.Text(""))
        
        if not mssql_data.get('local_crs') and not mssql_data.get('deployed_crs'):
            self.status_walker.append(urwid.Text(('status_unknown', '‚ùì No MSSQL services found')))
        
        # Summary
        mssql_summary = status_report.get('summary', {}).get('mssqlserver', {})
        self.status_walker.append(urwid.Text(('header', 'üìà MSSQL SUMMARY:')))
        self.status_walker.append(urwid.Text(f"Local CRs: {mssql_summary.get('local_count', 0)}"))
        self.status_walker.append(urwid.Text(f"Deployed CRs: {mssql_summary.get('deployed_count', 0)}"))
    
    def update_otel_status_display(self, status_report):
        """Update OpenTelemetry status display"""
        otel_data = status_report.get('otelcollectors', {})
        
        # Local CRs
        if otel_data.get('local_crs'):
            self.status_walker.append(urwid.Text(('service_otel', 'üìÅ LOCAL OTEL CRs:')))
            for name, cr_data in otel_data['local_crs'].items():
                target_vm = cr_data.get('target_vm', 'unknown')
                metrics_type = cr_data.get('metrics_type', 'unknown')
                enabled = cr_data.get('enabled', True)
                status_icon = '‚úÖ' if enabled else '‚è∏Ô∏è'
                self.status_walker.append(urwid.Text(('cr_local', f"  {status_icon} {name}: target={target_vm}, metrics={metrics_type}")))
            self.status_walker.append(urwid.Text(""))
        
        # Deployed CRs
        if otel_data.get('deployed_crs'):
            self.status_walker.append(urwid.Text(('service_otel', '‚ò∏Ô∏è DEPLOYED OTEL CRs:')))
            for name, cr_data in otel_data['deployed_crs'].items():
                target_vm = cr_data.get('target_vm', 'unknown')
                metrics_type = cr_data.get('metrics_type', 'unknown')
                status = cr_data.get('status', {}).get('phase', 'Unknown')
                
                if status == 'Ready':
                    color = 'status_running'
                    icon = 'üü¢'
                elif status == 'Failed':
                    color = 'status_stopped'
                    icon = 'üî¥'
                else:
                    color = 'status_unknown'
                    icon = 'üü°'
                
                self.status_walker.append(urwid.Text((color, f"  {icon} {name}: target={target_vm}, metrics={metrics_type}, status={status}")))
            self.status_walker.append(urwid.Text(""))
        
        if not otel_data.get('local_crs') and not otel_data.get('deployed_crs'):
            self.status_walker.append(urwid.Text(('status_unknown', '‚ùì No OpenTelemetry services found')))
        
        # Summary
        otel_summary = status_report.get('summary', {}).get('otelcollector', {})
        self.status_walker.append(urwid.Text(('header', 'üìà OTEL SUMMARY:')))
        self.status_walker.append(urwid.Text(f"Local CRs: {otel_summary.get('local_count', 0)}"))
        self.status_walker.append(urwid.Text(f"Deployed CRs: {otel_summary.get('deployed_count', 0)}"))
    
    def add_log_line(self, text):
        """Add a log line with color coding"""
        # Determine log level color
        if 'ERROR' in text.upper() or '‚ùå' in text:
            attr = 'log_error'
        elif 'WARNING' in text.upper() or 'WARN' in text.upper() or '‚ö†Ô∏è' in text:
            attr = 'log_warning'
        else:
            attr = 'log_info'
            
        log_widget = urwid.Text((attr, text))
        self.log_walker.append(log_widget)
        
        # Keep only recent logs
        if len(self.log_walker) > self.max_log_lines:
            self.log_walker.pop(0)
        
        # Auto-scroll if enabled
        if self.auto_scroll and self.log_walker:
            try:
                self.log_listbox.focus_position = len(self.log_walker) - 1
            except:
                pass
    
    # Menu action methods with central popup windows
    def install_menu(self, button):
        """Show install service selection in central popup"""
        self.show_service_selection_popup("INSTALL", [
            ("1", "Windows VM Deploy", "üñ•Ô∏è", "Deploy Windows Virtual Machines"),
            ("2", "MSSQL Windows Service Deploy", "üóÑÔ∏è", "Deploy SQL Server instances"),  
            ("3", "Windows OTel Service Deploy", "üìä", "Deploy OpenTelemetry collectors")
        ], self.handle_install_selection)
    
    def uninstall_menu(self, button):
        """Show uninstall service selection in central popup"""
        self.show_service_selection_popup("UNINSTALL", [
            ("1", "Windows VM Uninstall", "üñ•Ô∏è", "Remove Windows Virtual Machines"),
            ("2", "MSSQL Service Uninstall", "üóÑÔ∏è", "Remove SQL Server instances"),
            ("3", "OTel Service Uninstall", "üìä", "Remove OpenTelemetry collectors")
        ], self.handle_uninstall_selection)
    
    def apply_cr_menu(self, button):
        """Show apply CR service selection in central popup"""
        self.show_service_selection_popup("APPLY CRs", [
            ("1", "Windows VM CRs", "üñ•Ô∏è", "Apply Windows VM Custom Resources"),
            ("2", "MSSQL Service CRs", "üóÑÔ∏è", "Apply MSSQL Custom Resources"),
            ("3", "OTel Service CRs", "üìä", "Apply OpenTelemetry Custom Resources")
        ], self.handle_apply_selection)
    
    def delete_cr_menu(self, button):
        """Show delete CR service selection in central popup"""
        self.show_service_selection_popup("DELETE CRs", [
            ("1", "Windows VM CRs", "üñ•Ô∏è", "Delete Windows VM Custom Resources"),
            ("2", "MSSQL Service CRs", "üóÑÔ∏è", "Delete MSSQL Custom Resources"),
            ("3", "OTel Service CRs", "üìä", "Delete OpenTelemetry Custom Resources")
        ], self.handle_delete_selection)

    def show_cr_selection_popup(self, title, cr_options, callback):
        """Show CR selection in a dropdown popup with arrow navigation"""
        if not cr_options:
            self.add_log_line(f"‚ùå No CRs available for {title}")
            return
            
        # Create menu items for CRs
        menu_items = []
        for name, cr_data, status in cr_options:
            # Determine icon based on status
            if "Ready" in status:
                icon = "‚úÖ"
            elif "Already" in status or "Deployed" in status:
                icon = "üîÑ"
            elif "Unknown" in status:
                icon = "üî¥"
            elif "Disabled" in status:
                icon = "‚è∏Ô∏è"
            else:
                icon = "üìù"
                
            # Create button text
            button_text = f"{icon} {name}\n   {status}"
            
            # Create custom button that handles Enter key directly
            class CRButton(urwid.Button):
                def __init__(self, label, cr_name, cr_data, callback, parent_tui):
                    super().__init__(label)
                    self.cr_name = cr_name
                    self.cr_data = cr_data
                    self.callback = callback
                    self.parent_tui = parent_tui
                    
                def keypress(self, size, key):
                    self.parent_tui.add_log_line(f"üîë CRButton.keypress: Key={key} for {self.cr_name}")
                    if key == 'enter':
                        self.parent_tui.add_log_line(f"ÔøΩ CRButton: Enter pressed for {self.cr_name}!")
                        self.parent_tui.close_popup()
                        self.callback(self.cr_name, self.cr_data)
                        return None
                    return super().keypress(size, key)
            
            # Create button with custom handling
            def button_callback(button, cr_name=name, cr_data=cr_data):
                self.add_log_line(f"üî• Button callback triggered for: {cr_name}")
                self.close_popup()
                callback(cr_name, cr_data)
            
            # Create callback function that captures the CR data properly
            def make_callback(cr_name, cr_data):
                def callback_func(button):
                    self.add_log_line(f"üî• CR selected: {cr_name}")
                    self.close_popup()
                    callback(cr_name, cr_data)
                return callback_func
            
            # Create standard urwid button with on_press - the correct pattern
            def create_callback(cr_name, cr_data):
                def button_callback(button):
                    self.add_log_line(f"üî• CR selected: {cr_name}")
                    self.close_popup()
                    callback(cr_name, cr_data)
                return button_callback
            
            button = urwid.Button(button_text, on_press=create_callback(name, cr_data))
            button.cr_name = name
            button.cr_data = cr_data
            menu_items.append(urwid.AttrMap(button, 'button', 'button_focus'))
        
        # Use standard ListBox - urwid will handle Enter key properly
        menu_walker = urwid.SimpleListWalker(menu_items)
        menu_listbox = urwid.ListBox(menu_walker)
        
        # Create simple popup content
        popup_content = urwid.Pile([
            urwid.Text(('popup_title', f"üîΩ {title}"), align='center'),
            urwid.Divider('‚îÄ'),
            urwid.BoxAdapter(menu_listbox, height=min(len(menu_items), 6)),
            urwid.Divider('‚îÄ'),
            urwid.Text("‚Üë‚Üì: Navigate, 1-5: Quick Select, ESC: Cancel", align='center')
        ])
        
        popup_box = urwid.AttrMap(urwid.LineBox(popup_content, title=title), 'popup')
        
        # Center the popup
        overlay = urwid.Overlay(
            popup_box,
            self.main_frame,
            align='center', width=60,
            valign='middle', height=min(len(menu_items) + 6, 14)
        )
        
        self.popup = overlay
        self.popup_callback = callback  # Store callback for keyboard handling
        self.popup_listbox = menu_listbox  # Store listbox reference for Enter handling
        
        # Store original widget before showing popup
        if not hasattr(self, 'original_widget') or not self.original_widget:
            self.original_widget = self.loop.widget
        
        # Set menu state for CR popup
        self.menu_state = 'cr_popup'
        
        # Show popup
        self.loop.widget = overlay
        self.add_log_line(f"üìã {title} opened - use ‚Üë‚Üì and Enter")
    
    def show_service_selection_popup(self, action_title, service_options, callback):
        """Show a central popup window for service selection with arrow key navigation"""
        try:
            # Create selectable menu items using buttons
            menu_items = []
            
            for key, title, icon, description in service_options:
                # Create button text with icon and description
                button_text = f"{icon} {title}\n   {description}"
                
                # Create button with callback that stores the key
                def make_button_callback(option_key):
                    def button_callback(button):
                        self.close_popup()
                        callback(option_key)
                    return button_callback
                
                button = urwid.Button(button_text, on_press=make_button_callback(key))
                button.key = key  # Store key for Enter handling
                
                # Style the button
                styled_button = urwid.AttrMap(button, 'menu', 'menu_focus')
                menu_items.append(styled_button)
            
            # Create list walker and listbox with arrow navigation
            walker = urwid.SimpleFocusListWalker(menu_items)
            listbox = urwid.ListBox(walker)
            
            # Create popup content with title and instructions
            popup_content = urwid.Pile([
                urwid.Text(('header', f'üéØ {action_title} - SELECT SERVICE'), align='center'),
                urwid.Divider(),
                urwid.Text("Available Services:", align='center'),
                urwid.Divider(),
                urwid.BoxAdapter(listbox, height=len(service_options) * 3 + 2),
                urwid.Divider(),
                urwid.Text("Use ‚Üë‚Üì arrows and Enter to select, ESC to cancel", align='center')
            ])
            
            # Create dialog box
            dialog = urwid.LineBox(popup_content, title=f"üìã {action_title}")
            
            # Create overlay - centered popup
            self.selection_overlay = urwid.Overlay(
                dialog,
                self.main_frame,
                align='center',
                width=60,
                valign='middle', 
                height=len(service_options) * 3 + 10
            )
            
            # Store original widget and callback
            self.original_widget = self.loop.widget
            self.popup_callback = callback
            self.popup_action = action_title
            self.service_options = service_options
            self.popup_listbox = listbox
            
            # Switch to overlay
            self.loop.widget = self.selection_overlay
            self.menu_state = 'service_popup'
            
            self.add_log_line(f"üìã {action_title} service selection opened - use ‚Üë‚Üì and Enter")
            
        except Exception as e:
            self.add_log_line(f"‚ùå Error showing service selection popup: {e}")
    
    def close_popup(self):
        """Close the current popup and return to main interface"""
        if hasattr(self, 'original_widget') and self.original_widget:
            self.loop.widget = self.original_widget
            self.original_widget = None
            self.popup_callback = None
            self.popup_action = None
            self.service_options = None
            self.popup_listbox = None
            self.popup = None  # Clear popup reference
            self.menu_state = None
            self.add_log_line("üìã Popup closed")
    
    def handle_install_selection(self, service_key):
        """Handle install service selection"""
        service_map = {
            '1': ('vms', 'Windows VMs'),
            '2': ('mssql', 'MSSQL Services'),
            '3': ('otel', 'OpenTelemetry Services')
        }
        
        if service_key in service_map:
            service_type, service_name = service_map[service_key]
            self.add_log_line(f"üöÄ Selected: Install {service_name}")
            # Go directly to CR selection for install
            self.show_cr_selection_for_install(service_type, service_name)
    
    def handle_uninstall_selection(self, service_key):
        """Handle uninstall service selection"""
        service_map = {
            '1': ('vms', 'Windows VMs'),
            '2': ('mssql', 'MSSQL Services'), 
            '3': ('otel', 'OpenTelemetry Services')
        }
        
        if service_key in service_map:
            service_type, service_name = service_map[service_key]
            self.add_log_line(f"üóëÔ∏è Selected: Uninstall {service_name}")
            # Go directly to CR selection for uninstall
            self.show_cr_selection_for_uninstall(service_type, service_name)
    
    def show_cr_selection_for_install(self, service_type, service_name):
        """Show available CRs for installation using popup menu"""
        self.add_log_line(f"üìã Loading {service_name} CRs for installation...")
        
        try:
            status_report = self.service_manager.get_comprehensive_status()
            service_map = {
                'vms': 'windowsvms',
                'mssql': 'mssqlservers',
                'otel': 'otelcollectors'
            }
            
            service_key = service_map.get(service_type)
            if service_key and service_key in status_report:
                service_data = status_report[service_key]
                local_crs = service_data.get('local_crs', {})
                deployed_crs = service_data.get('deployed_crs', {})
                
                if local_crs:
                    installable_crs = []
                    for name, cr_data in local_crs.items():
                        enabled = cr_data.get('enabled', True)
                        is_deployed = name in deployed_crs
                        
                        if enabled and not is_deployed:
                            status_text = "Ready to Install"
                            installable_crs.append((name, cr_data, status_text))
                        elif enabled and is_deployed:
                            status_text = "Already Deployed"
                            installable_crs.append((name, cr_data, status_text))
                        elif not enabled:
                            status_text = "Disabled"
                            installable_crs.append((name, cr_data, status_text))
                    
                    if installable_crs:
                        # Use popup for CR selection
                        def handle_cr_install_selection(cr_name, cr_data):
                            """Handle CR selection for install"""
                            self.add_log_line(f"üéØ handle_cr_install_selection called with CR: {cr_name}")
                            self.execute_cr_install(service_type, service_name, cr_name, cr_data)
                        
                        self.show_cr_selection_popup(
                            f"Install {service_name} CR", 
                            installable_crs, 
                            handle_cr_install_selection
                        )
                    else:
                        self.add_log_line("‚ùå No installable CRs found")
                        self.add_log_line("üí° All CRs are either deployed or disabled")
                else:
                    self.add_log_line(f"‚ùå No local {service_name} CRs found")
                    self.add_log_line("üí° Create CR files first or check manifest-controller directory")
            else:
                self.add_log_line(f"‚ùå Service type {service_type} not supported or no data available")
                
        except Exception as e:
            self.add_log_line(f"‚ùå Error loading CRs: {e}")
    
    def show_cr_selection_for_uninstall(self, service_type, service_name):
        """Show deployed CRs for uninstallation using popup menu"""
        self.add_log_line(f"üìã Loading deployed {service_name} CRs for uninstallation...")
        
        try:
            status_report = self.service_manager.get_comprehensive_status()
            service_map = {
                'vms': 'windowsvms',
                'mssql': 'mssqlservers',
                'otel': 'otelcollectors'
            }
            
            service_key = service_map.get(service_type)
            if service_key and service_key in status_report:
                service_data = status_report[service_key]
                deployed_crs = service_data.get('deployed_crs', {})
                
                if deployed_crs:
                    uninstallable_crs = []
                    for name, cr_data in deployed_crs.items():
                        status = cr_data.get('status', {}).get('phase', 'Unknown')
                        status_text = f"Status: {status}"
                        uninstallable_crs.append((name, cr_data, status_text))
                    
                    if uninstallable_crs:
                        # Use popup for CR selection
                        def handle_cr_uninstall_selection(cr_name, cr_data):
                            """Handle CR selection for uninstall"""
                            self.execute_cr_uninstall(service_type, service_name, cr_name, cr_data)
                        
                        self.show_cr_selection_popup(
                            f"Uninstall {service_name} CR", 
                            uninstallable_crs, 
                            handle_cr_uninstall_selection
                        )
                    else:
                        self.add_log_line(f"‚ùå No deployed {service_name} CRs found")
                        self.add_log_line("üí° Nothing to uninstall")
                else:
                    self.add_log_line(f"‚ùå No deployed {service_name} CRs found")
                    self.add_log_line("üí° Nothing to uninstall")
            else:
                self.add_log_line(f"‚ùå Service type {service_type} not supported or no data available")
                
        except Exception as e:
            self.add_log_line(f"‚ùå Error loading deployed CRs: {e}")
    
    def show_cr_selection_for_apply(self, service_type, service_name):
        """Show local CRs for application using popup menu"""
        self.add_log_line(f"üìã Loading {service_name} CRs for application...")
        
        try:
            status_report = self.service_manager.get_comprehensive_status()
            service_map = {
                'vms': 'windowsvms',
                'mssql': 'mssqlservers',
                'otel': 'otelcollectors'
            }
            
            service_key = service_map.get(service_type)
            if service_key and service_key in status_report:
                service_data = status_report[service_key]
                local_crs = service_data.get('local_crs', {})
                
                if local_crs:
                    applicable_crs = []
                    for name, cr_data in local_crs.items():
                        # For apply, show all local CRs
                        action = cr_data.get('action', 'unknown')
                        status_text = f"Action: {action}"
                        applicable_crs.append((name, cr_data, status_text))
                    
                    if applicable_crs:
                        # Use popup for CR selection
                        def handle_cr_apply_selection(cr_name, cr_data):
                            """Handle CR selection for apply"""
                            self.execute_cr_apply(service_type, service_name, cr_name, cr_data)
                        
                        self.show_cr_selection_popup(
                            f"Apply {service_name} CR", 
                            applicable_crs, 
                            handle_cr_apply_selection
                        )
                    else:
                        self.add_log_line(f"‚ùå No local {service_name} CRs found")
                        self.add_log_line("üí° Create CR files first in manifest-controller directory")
                else:
                    self.add_log_line(f"‚ùå No local {service_name} CRs found")
                    self.add_log_line("üí° Create CR files first in manifest-controller directory")
            else:
                self.add_log_line(f"‚ùå Service type {service_type} not supported or no data available")
                
        except Exception as e:
            self.add_log_line(f"‚ùå Error loading local CRs: {e}")

    def handle_apply_selection(self, service_key):
        """Handle apply CR service selection"""
        service_map = {
            '1': ('vms', 'WindowsVM'),
            '2': ('mssql', 'MSSQL'),
            '3': ('otel', 'OTel')
        }
        
        if service_key in service_map:
            service_type, service_name = service_map[service_key]
            self.add_log_line(f"üìù Selected: Apply {service_name} CRs")
            self.show_cr_selection_for_apply(service_type, service_name)
    
    def handle_delete_selection(self, service_key):
        """Handle delete CR service selection"""
        service_map = {
            '1': ('vms', 'Windows VM CRs'),
            '2': ('mssql', 'MSSQL CRs'),
            '3': ('otel', 'OpenTelemetry CRs')
        }
        
        if service_key in service_map:
            service_type, service_name = service_map[service_key]
            self.add_log_line(f"üóëÔ∏è Selected: Delete {service_name}")
            self.show_delete_method_selection(service_type, service_name)
    
    def show_install_method_selection(self, service_type, service_name):
        """Show method selection for install"""
        self.add_log_line("")
        self.add_log_line(f"üîß Choose Install Method for {service_name}:")
        self.add_log_line("1Ô∏è‚É£ kubectl apply - Direct Kubernetes deployment") 
        self.add_log_line("2Ô∏è‚É£ Ansible Playbook - Automated provisioning")
        self.add_log_line("3Ô∏è‚É£ Manual CR Generation - Create files only")
        self.add_log_line("")
        self.add_log_line("Press 1-3 to select method...")
        
        self.menu_state = 'install_method_selection'
        self.selected_service_type = service_type
        self.selected_service_name = service_name
    
    def show_uninstall_method_selection(self, service_type, service_name):
        """Show method selection for uninstall"""
        self.add_log_line("")
        self.add_log_line(f"üîß Choose Uninstall Method for {service_name}:")
        self.add_log_line("1Ô∏è‚É£ kubectl delete - Remove from Kubernetes")
        self.add_log_line("2Ô∏è‚É£ Ansible Cleanup - Full resource cleanup") 
        self.add_log_line("3Ô∏è‚É£ CR Update to 'uninstall' - Modify existing CR")
        self.add_log_line("")
        self.add_log_line("Press 1-3 to select method...")
        
        self.menu_state = 'uninstall_method_selection'
        self.selected_service_type = service_type
        self.selected_service_name = service_name
    
    def show_delete_method_selection(self, service_type, service_name):
        """Show method selection for delete CRs"""
        self.add_log_line("")
        self.add_log_line(f"üîß Choose Delete Method for {service_name}:")
        self.add_log_line("1Ô∏è‚É£ kubectl delete - Remove from cluster")
        self.add_log_line("2Ô∏è‚É£ Graceful shutdown - Stop services first")
        self.add_log_line("3Ô∏è‚É£ Force delete - Immediate removal")
        self.add_log_line("")
        self.add_log_line("Press 1-3 to select method...")
        
        self.menu_state = 'delete_method_selection'
        self.selected_service_type = service_type
        self.selected_service_name = service_name
    
    def show_service_selection_for_install(self):
        """Show service type selection for installation"""
        self.add_log_line("")
        self.add_log_line(f"Step 2: Select Service Type (Method: {self.selected_method})")
        self.add_log_line("")
        self.add_log_line("Available Services:")
        self.add_log_line("1Ô∏è‚É£ Windows VMs - Virtual Machine deployment")
        self.add_log_line("2Ô∏è‚É£ MSSQL Servers - SQL Server instances")
        self.add_log_line("3Ô∏è‚É£ OpenTelemetry - Monitoring collectors")
        self.add_log_line("")
        self.add_log_line("Press 1-3 to select service type...")
        self.menu_state = 'service_selection'
    
    def show_service_selection_for_uninstall(self):
        """Show service type selection for uninstallation"""
        self.add_log_line("")
        self.add_log_line(f"Step 2: Select Service Type (Method: {self.selected_method})")
        self.add_log_line("")
        self.add_log_line("Available Services:")
        self.add_log_line("1Ô∏è‚É£ Windows VMs - Running virtual machines")
        self.add_log_line("2Ô∏è‚É£ MSSQL Servers - Active SQL instances")
        self.add_log_line("3Ô∏è‚É£ OpenTelemetry - Running collectors")
        self.add_log_line("")
        self.add_log_line("Press 1-3 to select service type...")
        self.menu_state = 'service_selection'
    
    def handle_service_selection(self, key):
        """Handle service type selection"""
        service_map = {
            '1': ('vms', 'Windows VMs'),
            '2': ('mssql', 'MSSQL Servers'),
            '3': ('otel', 'OpenTelemetry Collectors')
        }
        
        if key not in service_map:
            return
            
        service_type, service_name = service_map[key]
        self.add_log_line(f"‚úÖ Selected: {service_name}")
        
        # Switch to the appropriate tab first
        self.active_service_tab = service_type
        if service_type == 'vms':
            self.show_vms_tab(None)
        elif service_type == 'mssql':
            self.show_mssql_tab(None)
        elif service_type == 'otel':
            self.show_otel_tab(None)
        
        # Now execute the action based on method and service
        self.execute_selected_action(service_type, service_name)
        
        # Reset menu state
        self.menu_state = None
    
    def execute_selected_action(self, service_type, service_name):
        """Execute the selected action with method and service type"""
        action = self.pending_action
        method = self.selected_method
        
        self.add_log_line("")
        self.add_log_line(f"üéØ Executing: {action.upper()} {service_name}")
        self.add_log_line(f"üîß Method: {method}")
        self.add_log_line("")
        
        if action == 'install':
            self.execute_install_action(service_type, method)
        elif action == 'uninstall':
            self.execute_uninstall_action(service_type, method)
        
        # Reset state
        self.pending_action = None
        self.selected_method = None
    
    def execute_install_action(self, service_type, method):
        """Execute installation with specified method"""
        try:
            status_report = self.service_manager.get_comprehensive_status()
            
            if method == 'kubectl':
                self.add_log_line("üìã Available local CRs for kubectl apply:")
                self.show_available_crs_for_install(service_type, status_report)
                self.add_log_line("üí° Use 'Apply CRs' menu to select specific CRs")
                
            elif method == 'ansible':
                self.add_log_line("üìã Available services for Ansible deployment:")
                self.show_available_services_for_ansible(service_type, status_report)
                self.add_log_line("üí° Ansible will handle full provisioning workflow")
                
            elif method == 'manual':
                self.add_log_line("üìù Manual CR generation mode:")
                self.add_log_line("‚Ä¢ Generate CR files without applying")
                self.add_log_line("‚Ä¢ Review and modify before deployment")
                self.add_log_line("üí° Use 'Fix Issues' to generate missing CRs")
                
        except Exception as e:
            self.add_log_line(f"‚ùå Error in install action: {e}")
    
    def execute_uninstall_action(self, service_type, method):
        """Execute uninstallation with specified method"""
        try:
            status_report = self.service_manager.get_comprehensive_status()
            
            if method == 'kubectl':
                self.add_log_line("üìã Deployed CRs available for kubectl delete:")
                self.show_deployed_crs_for_delete(service_type, status_report)
                self.add_log_line("üí° Use 'Delete CR' menu to remove specific CRs")
                
            elif method == 'ansible':
                self.add_log_line("üìã Running services for Ansible cleanup:")
                self.show_running_services_for_cleanup(service_type, status_report)
                self.add_log_line("üí° Ansible will handle full cleanup workflow")
                
            elif method == 'cr_update':
                self.add_log_line("üìù CR update mode (action: uninstall):")
                self.add_log_line("‚Ä¢ Modify local CRs to set action='uninstall'")
                self.add_log_line("‚Ä¢ Apply updated CRs to trigger uninstall")
                self.add_log_line("üí° Safer method that preserves configuration")
                
        except Exception as e:
            self.add_log_line(f"‚ùå Error in uninstall action: {e}")
    
    def show_available_crs_for_install(self, service_type, status_report):
        """Show available CRs for the selected service type"""
        service_map = {
            'vms': 'windowsvms',
            'mssql': 'mssqlservers', 
            'otel': 'otelcollectors'
        }
        
        service_key = service_map.get(service_type)
        if not service_key:
            return
            
        service_data = status_report.get(service_key, {})
        local_crs = service_data.get('local_crs', {})
        
        if local_crs:
            for name, cr_data in local_crs.items():
                enabled = cr_data.get('enabled', True)
                status_icon = '‚úÖ' if enabled else '‚è∏Ô∏è'
                self.add_log_line(f"  {status_icon} {name}")
        else:
            self.add_log_line(f"  ‚ùå No local {service_type} CRs found")
    
    def show_deployed_crs_for_delete(self, service_type, status_report):
        """Show deployed CRs for the selected service type"""
        service_map = {
            'vms': 'windowsvms',
            'mssql': 'mssqlservers',
            'otel': 'otelcollectors'
        }
        
        service_key = service_map.get(service_type)
        if not service_key:
            return
            
        service_data = status_report.get(service_key, {})
        deployed_crs = service_data.get('deployed_crs', {})
        
        if deployed_crs:
            for name, cr_data in deployed_crs.items():
                status = cr_data.get('status', {}).get('phase', 'Unknown')
                self.add_log_line(f"  üóëÔ∏è {name} (status: {status})")
        else:
            self.add_log_line(f"  ‚ùå No deployed {service_type} CRs found")
    
    def show_available_services_for_ansible(self, service_type, status_report):
        """Show available services for Ansible deployment"""
        self.add_log_line("  üîß Ansible will provision:")
        self.add_log_line(f"    ‚Ä¢ {service_type.title()} instances")
        self.add_log_line("    ‚Ä¢ Required dependencies")
        self.add_log_line("    ‚Ä¢ Network configuration")
        self.add_log_line("    ‚Ä¢ Storage resources")
    
    def show_running_services_for_cleanup(self, service_type, status_report):
        """Show running services for cleanup"""
        if service_type == 'vms':
            scenarios = status_report.get('scenarios', {})
            running_vms = [name for name, data in scenarios.items() 
                          if 'Running' in data.get('scenario', '')]
            if running_vms:
                for vm_name in running_vms:
                    self.add_log_line(f"  üñ•Ô∏è {vm_name}")
            else:
                self.add_log_line("  ‚ùå No running VMs found")
        else:
            self.add_log_line(f"  üîß Will clean up all {service_type} resources")
    
    def show_available_crs_for_apply(self):
        """Show available CRs for the current active tab"""
        self.add_log_line("")
        self.add_log_line(f"Step 2: Available CRs for {self.active_service_tab.upper()} (Method: {self.selected_method})")
        self.add_log_line("")
        
        try:
            status_report = self.service_manager.get_comprehensive_status()
            
            service_map = {
                'vms': 'windowsvms',
                'mssql': 'mssqlservers',
                'otel': 'otelcollectors'
            }
            
            service_key = service_map.get(self.active_service_tab)
            if service_key:
                service_data = status_report.get(service_key, {})
                local_crs = service_data.get('local_crs', {})
                deployed_crs = service_data.get('deployed_crs', {})
                
                if local_crs:
                    self.add_log_line("üìÅ Local CRs available for apply:")
                    for name, cr_data in local_crs.items():
                        enabled = cr_data.get('enabled', True)
                        is_deployed = name in deployed_crs
                        status_icon = '‚úÖ' if enabled else '‚è∏Ô∏è'
                        deploy_status = ' (Already Deployed)' if is_deployed else ' (Ready to Deploy)'
                        self.add_log_line(f"  {status_icon} {name}{deploy_status}")
                else:
                    self.add_log_line(f"‚ùå No local {self.active_service_tab} CRs found")
                    
                if self.selected_method == 'batch' and local_crs:
                    enabled_count = sum(1 for cr in local_crs.values() if cr.get('enabled', True))
                    self.add_log_line("")
                    self.add_log_line(f"üöÄ Batch mode will apply {enabled_count} enabled CRs")
                elif self.selected_method == 'dry_run':
                    self.add_log_line("")
                    self.add_log_line("üîç Dry-run will validate CRs without applying")
                    
        except Exception as e:
            self.add_log_line(f"‚ùå Error loading CRs: {e}")
            
        self.add_log_line("")
        self.add_log_line("üí° Use F3/F4/F5 to switch service tabs, then rerun Apply CRs")
        self.menu_state = None  # Reset menu state
        self.pending_action = None
        self.selected_method = None
    
    def show_deployed_crs_for_delete_action(self):
        """Show deployed CRs for the current active tab"""
        self.add_log_line("")
        self.add_log_line(f"Step 2: Deployed CRs for {self.active_service_tab.upper()} (Method: {self.selected_method})")
        self.add_log_line("")
        
        try:
            status_report = self.service_manager.get_comprehensive_status()
            
            service_map = {
                'vms': 'windowsvms',
                'mssql': 'mssqlservers',
                'otel': 'otelcollectors'
            }
            
            service_key = service_map.get(self.active_service_tab)
            if service_key:
                service_data = status_report.get(service_key, {})
                deployed_crs = service_data.get('deployed_crs', {})
                
                if deployed_crs:
                    self.add_log_line("‚ò∏Ô∏è Deployed CRs available for deletion:")
                    for name, cr_data in deployed_crs.items():
                        status = cr_data.get('status', {}).get('phase', 'Unknown')
                        color_icon = 'üü¢' if status == 'Ready' else 'üü°' if status == 'Pending' else 'üî¥'
                        method_note = ''
                        if self.selected_method == 'graceful':
                            method_note = ' (Will stop services first)'
                        elif self.selected_method == 'force':
                            method_note = ' (Immediate removal)'
                        self.add_log_line(f"  {color_icon} {name} (status: {status}){method_note}")
                else:
                    self.add_log_line(f"‚ùå No deployed {self.active_service_tab} CRs found")
                    
                if self.selected_method == 'graceful':
                    self.add_log_line("")
                    self.add_log_line("üîÑ Graceful shutdown will:")
                    self.add_log_line("  ‚Ä¢ Stop running services cleanly")
                    self.add_log_line("  ‚Ä¢ Wait for processes to terminate")
                    self.add_log_line("  ‚Ä¢ Remove CRs after cleanup")
                elif self.selected_method == 'force':
                    self.add_log_line("")
                    self.add_log_line("‚ö†Ô∏è Force delete will immediately remove CRs")
                    self.add_log_line("   This may leave orphaned resources!")
                    
        except Exception as e:
            self.add_log_line(f"‚ùå Error loading deployed CRs: {e}")
            
        self.add_log_line("")
        self.add_log_line("üí° Use F3/F4/F5 to switch service tabs, then rerun Delete CR")
        self.menu_state = None  # Reset menu state
        self.pending_action = None
        self.selected_method = None
    
    def delete_cr_menu(self, button):
        """Show delete CR method selection"""
        self.add_log_line("üóëÔ∏è === DELETE CR MENU ===")
        self.add_log_line("Step 1: Select Delete Method")
        self.add_log_line("")
        self.add_log_line("Available Methods:")
        self.add_log_line("1Ô∏è‚É£ kubectl delete - Remove from cluster")
        self.add_log_line("2Ô∏è‚É£ Graceful shutdown - Stop services first")
        self.add_log_line("3Ô∏è‚É£ Force delete - Immediate removal")
        self.add_log_line("")
        self.add_log_line("Press 1-3 to select method...")
        self.menu_state = 'delete_method_selection'
        self.pending_action = 'delete'
    
    def fix_issues(self, button):
        """Smart issue fixing"""
        self.add_log_line("üîß === FIX ISSUES (SMART) ===")
        self.add_log_line("Analyzing system for common issues...")
        self.add_log_line("‚Ä¢ Orphaned VMs")
        self.add_log_line("‚Ä¢ Missing CRs")
        self.add_log_line("‚Ä¢ Service mismatches")
        self.add_log_line("TODO: Implement smart issue detection")
    
    def clear_logs(self, button):
        """Clear log display"""
        self.log_walker.clear()
        self.add_log_line("üßπ Logs cleared")
    
    def quit_app(self, button):
        """Quit application"""
        raise urwid.ExitMainLoop()
    
    def update_focus_indicators(self):
        """Update focus indicators in panel titles"""
        current_focus = self.content_columns.focus_position
        if current_focus == 0:
            self.status_frame.set_title("VMs & Services Status [FOCUSED]")
            self.log_frame.set_title("System Logs")
        else:
            self.status_frame.set_title("VMs & Services Status")
            self.log_frame.set_title("System Logs [FOCUSED]")
    
    def reset_focus_and_navigation(self):
        """Reset focus and navigation state"""
        try:
            self.content_columns.focus_position = 1  # Default to logs
            self.update_focus_indicators()
            self.add_log_line("üîÑ Focus and navigation reset")
        except Exception as e:
            self.add_log_line(f"‚ùå Reset failed: {e}")
    
    def unhandled_input(self, key):
        """Handle keyboard input with popup support"""
        # Debug: Log ALL key presses to see what's happening
        self.add_log_line(f"üîç GLOBAL KEY: {key}, menu_state: {self.menu_state}, has_popup: {hasattr(self, 'popup') and self.popup is not None}")
        
        # Handle popup service selection
        if self.menu_state == 'service_popup':
            if key == 'escape':
                self.close_popup()
                return
            elif key == 'enter':
                # Get the currently focused button and activate it
                try:
                    focus_widget = self.popup_listbox.focus
                    if hasattr(focus_widget, 'original_widget') and hasattr(focus_widget.original_widget, 'key'):
                        selected_key = focus_widget.original_widget.key
                        self.close_popup()
                        self.popup_callback(selected_key)
                        return
                    else:
                        # Try to activate the button directly
                        if hasattr(focus_widget, 'original_widget'):
                            focus_widget.original_widget.keypress((0, 0), 'enter')
                            return
                except Exception as e:
                    self.add_log_line(f"‚ùå Error getting selection: {e}")
                    return
            elif key in ('1', '2', '3') and hasattr(self, 'popup_callback'):
                # Still support number key shortcuts
                self.close_popup()
                self.popup_callback(key)
                return
            elif key in ('up', 'down'):
                # Let the listbox handle arrow navigation
                return
        
        # Handle CR popup selection
        elif self.menu_state == 'cr_popup':
            self.add_log_line(f"üîë CR_POPUP: Key={key} received in unhandled_input!")
            if key == 'escape':
                self.close_popup()
                return
            elif key in ('1', '2', '3', '4', '5'):
                # Handle number key shortcuts for CR selection
                self.add_log_line(f"üîë CR_POPUP: Number key {key} pressed!")
                try:
                    index = int(key) - 1  # Convert to 0-based index
                    if hasattr(self, 'popup_listbox') and self.popup_listbox:
                        if index < len(self.popup_listbox.body):
                            # Get the button at the specified index
                            button_widget = self.popup_listbox.body[index]
                            if hasattr(button_widget, 'original_widget'):
                                button = button_widget.original_widget
                                if hasattr(button, 'cr_name') and hasattr(button, 'cr_data'):
                                    self.add_log_line(f"üî• Number shortcut selecting: {button.cr_name}")
                                    cr_name = button.cr_name
                                    cr_data = button.cr_data
                                    self.close_popup()
                                    if hasattr(self, 'popup_callback') and self.popup_callback:
                                        self.popup_callback(cr_name, cr_data)
                                    return
                except Exception as e:
                    self.add_log_line(f"‚ùå Error with number shortcut: {str(e)}")
                return
            elif key == 'enter':
                self.add_log_line(f"üîë CR_POPUP: Processing Enter key!")
                # Use the stored listbox reference for simpler access
                try:
                    if hasattr(self, 'popup_listbox') and self.popup_listbox:
                        focus_widget = self.popup_listbox.focus
                        self.add_log_line(f"üîç Focus widget: {type(focus_widget)}")
                        if hasattr(focus_widget, 'original_widget'):
                            # Get the button
                            button = focus_widget.original_widget
                            self.add_log_line(f"üîç Found button: {type(button)}")
                            
                            # Try direct callback using stored data
                            if hasattr(button, 'cr_name') and hasattr(button, 'cr_data'):
                                self.add_log_line(f"üî• Direct callback for CR: {button.cr_name}")
                                cr_name = button.cr_name
                                cr_data = button.cr_data
                                self.close_popup()
                                if hasattr(self, 'popup_callback') and self.popup_callback:
                                    self.add_log_line(f"üî• Calling popup_callback!")
                                    self.popup_callback(cr_name, cr_data)
                                return
                            else:
                                self.add_log_line(f"‚ùå Button missing cr_name/cr_data")
                                
                except Exception as e:
                    self.add_log_line(f"‚ùå Error handling Enter: {str(e)}")
                return
            elif key in ('up', 'down'):
                # Let the listbox handle arrow navigation
                return key
        
        # Handle other popup types
        elif self.popup:
            if key == 'escape':
                self.close_popup()
                return
            elif key in ('up', 'down'):
                # Let the listbox handle arrow navigation
                return key
        
        
        # Handle method selection states
        elif self.menu_state == 'install_method_selection':
            if key == '1':
                self.selected_method = 'kubectl'
                self.add_log_line("‚úÖ Selected: kubectl apply method")
                self.execute_install_with_method()
                return
            elif key == '2':
                self.selected_method = 'ansible'
                self.add_log_line("‚úÖ Selected: Ansible Playbook method")
                self.execute_install_with_method()
                return
            elif key == '3':
                self.selected_method = 'manual'
                self.add_log_line("‚úÖ Selected: Manual CR Generation")
                self.execute_install_with_method()
                return
        elif self.menu_state == 'uninstall_method_selection':
            if key == '1':
                self.selected_method = 'kubectl'
                self.add_log_line("‚úÖ Selected: kubectl delete method")
                self.execute_uninstall_with_method()
                return
            elif key == '2':
                self.selected_method = 'ansible'
                self.add_log_line("‚úÖ Selected: Ansible Cleanup method")
                self.execute_uninstall_with_method()
                return
            elif key == '3':
                self.selected_method = 'cr_update'
                self.add_log_line("‚úÖ Selected: CR Update method")
                self.execute_uninstall_with_method()
                return
        elif self.menu_state == 'delete_method_selection':
            if key == '1':
                self.selected_method = 'kubectl'
                self.add_log_line("‚úÖ Selected: kubectl delete method")
                self.execute_delete_with_method()
                return
            elif key == '2':
                self.selected_method = 'graceful'
                self.add_log_line("‚úÖ Selected: Graceful shutdown")
                self.execute_delete_with_method()
                return
            elif key == '3':
                self.selected_method = 'force'
                self.add_log_line("‚úÖ Selected: Force delete")
                self.execute_delete_with_method()
                return
        
        # Standard navigation and shortcuts
        if key in ('q', 'Q'):
            raise urwid.ExitMainLoop()
        elif key == 'ctrl c':
            self.add_log_line("üõë CTRL+C pressed - Shutting down...")
            raise urwid.ExitMainLoop()
        elif key == 'escape':
            # Escape key resets menu state
            if self.menu_state:
                self.add_log_line("üîô Menu cancelled - returning to main")
                self.menu_state = None
                self.reset_menu_state()
            return
        elif key == 'f2':
            # F2 - Show current tab status
            self.update_status_display()
            self.add_log_line("üìä Status refreshed (F2)")
        elif key == 'f6':
            # F6 - Install menu
            self.install_menu(None)
        elif key == 'f7':
            # F7 - Apply CR menu
            self.apply_cr_menu(None)
        elif key == 'f2':
            # F2 - Show current tab status
            self.update_status_display()
            self.add_log_line("üìä Status refreshed (F2)")
        elif key == 'f3':
            # F3 - VMs tab
            self.show_vms_tab(None)
        elif key == 'f4':
            # F4 - MSSQL tab
            self.show_mssql_tab(None)
        elif key == 'f5':
            # F5 - OTel tab
            self.show_otel_tab(None)
        elif key == 'f6':
            # F6 - Install menu
            self.install_menu(None)
        elif key == 'f7':
            # F7 - Apply CR menu
            self.apply_cr_menu(None)
        elif key == 'f8':
            # F8 - Toggle auto-scroll
            self.auto_scroll = not self.auto_scroll
            status = "ON" if self.auto_scroll else "OFF"
            self.add_log_line(f"üìú Auto-scroll: {status} (F8)")
            if self.auto_scroll and self.log_walker:
                try:
                    self.log_listbox.focus_position = len(self.log_walker) - 1
                except:
                    pass
        elif key == 'f9':
            # F9 - Reset focus
            self.reset_focus_and_navigation()
        elif key in ('left', 'right'):
            # Arrow keys for panel navigation
            try:
                if key == 'left':
                    self.content_columns.focus_position = 0
                    self.update_focus_indicators()
                    self.add_log_line("üìä Moved to Status Panel (‚Üê)")
                else:
                    self.content_columns.focus_position = 1
                    self.update_focus_indicators()
                    self.add_log_line("üìú Moved to Log Panel (‚Üí)")
            except Exception as e:
                self.add_log_line(f"‚ùå Navigation error: {e}")
        elif key == 'tab':
            # Tab navigation
            try:
                current_focus = self.content_columns.focus_position
                new_focus = 1 - current_focus
                self.content_columns.focus_position = new_focus
                self.update_focus_indicators()
                
                if new_focus == 0:
                    self.add_log_line("üìä Switched to Status Panel (Tab)")
                else:
                    self.add_log_line("üìú Switched to Log Panel (Tab)")
            except Exception as e:
                self.add_log_line(f"‚ùå Tab navigation error: {e}")
        elif key in ('up', 'down', 'page up', 'page down'):
            # Handle scrolling - disable auto-scroll when manually scrolling
            try:
                if self.content_columns.focus_position == 1:  # Logs panel focused
                    self.auto_scroll = False
                return key
            except Exception as e:
                self.add_log_line(f"‚ùå Scrolling error: {e}")
                return
        else:
            return key
    
    def reset_menu_state(self):
        """Reset all menu state variables"""
        self.pending_action = None
        self.selected_method = None
        self.selected_service_type = None
        self.selected_service_name = None
        self.popup_callback = None
        self.popup_action = None
        self.service_options = None
        self.popup_listbox = None
    
    def execute_install_with_method(self):
        """Execute install action with selected service and method"""
        self.add_log_line("")
        self.add_log_line(f"üéØ INSTALLING {self.selected_service_name}")
        self.add_log_line(f"üîß Method: {self.selected_method}")
        self.add_log_line("")
        
        try:
            status_report = self.service_manager.get_comprehensive_status()
            
            if self.selected_method == 'kubectl':
                self.show_available_crs_for_install_final(self.selected_service_type, status_report)
            elif self.selected_method == 'ansible':
                self.show_ansible_install_options(self.selected_service_type, status_report)
            elif self.selected_method == 'manual':
                self.show_manual_cr_generation(self.selected_service_type, status_report)
                
        except Exception as e:
            self.add_log_line(f"‚ùå Error in install execution: {e}")
        finally:
            self.reset_menu_state()
    
    def execute_uninstall_with_method(self):
        """Execute uninstall action with selected service and method"""
        self.add_log_line("")
        self.add_log_line(f"üéØ UNINSTALLING {self.selected_service_name}")
        self.add_log_line(f"üîß Method: {self.selected_method}")
        self.add_log_line("")
        
        try:
            status_report = self.service_manager.get_comprehensive_status()
            
            if self.selected_method == 'kubectl':
                self.show_deployed_crs_for_uninstall(self.selected_service_type, status_report)
            elif self.selected_method == 'ansible':
                self.show_ansible_cleanup_options(self.selected_service_type, status_report)
            elif self.selected_method == 'cr_update':
                self.show_cr_update_options(self.selected_service_type, status_report)
                
        except Exception as e:
            self.add_log_line(f"‚ùå Error in uninstall execution: {e}")
        finally:
            self.reset_menu_state()
    
    def execute_delete_with_method(self):
        """Execute delete CRs with selected service and method"""
        self.add_log_line("")
        self.add_log_line(f"üéØ DELETING {self.selected_service_name}")
        self.add_log_line(f"üîß Method: {self.selected_method}")
        self.add_log_line("")
        
        try:
            status_report = self.service_manager.get_comprehensive_status()
            self.show_deployed_crs_for_delete_final(self.selected_service_type, status_report)
        except Exception as e:
            self.add_log_line(f"‚ùå Error in delete execution: {e}")
        finally:
            self.reset_menu_state()
    
    def show_available_crs_for_install_final(self, service_type, status_report):
        """Show final CR list for install"""
        service_map = {
            'vms': 'windowsvms',
            'mssql': 'mssqlservers',
            'otel': 'otelcollectors'
        }
        
        service_key = service_map.get(service_type)
        if service_key:
            service_data = status_report.get(service_key, {})
            local_crs = service_data.get('local_crs', {})
            
            if local_crs:
                self.add_log_line("üìÅ Available CRs for installation:")
                for name, cr_data in local_crs.items():
                    enabled = cr_data.get('enabled', True)
                    status_icon = '‚úÖ' if enabled else '‚è∏Ô∏è'
                    self.add_log_line(f"  {status_icon} {name}")
                self.add_log_line("")
                self.add_log_line("üí° Ready to install - use service manager integration")
            else:
                self.add_log_line(f"‚ùå No local {service_type} CRs found")
    
    def show_available_crs_for_apply_final(self, service_type, status_report):
        """Show final CR list for apply"""
        service_map = {
            'vms': 'windowsvms',
            'mssql': 'mssqlservers',
            'otel': 'otelcollectors'
        }
        
        service_key = service_map.get(service_type)
        if service_key:
            service_data = status_report.get(service_key, {})
            local_crs = service_data.get('local_crs', {})
            deployed_crs = service_data.get('deployed_crs', {})
            
            if local_crs:
                self.add_log_line("üìÅ CRs available for apply:")
                for name, cr_data in local_crs.items():
                    enabled = cr_data.get('enabled', True)
                    is_deployed = name in deployed_crs
                    status_icon = '‚úÖ' if enabled else '‚è∏Ô∏è'
                    deploy_status = ' (Already Deployed)' if is_deployed else ' (Ready to Deploy)'
                    self.add_log_line(f"  {status_icon} {name}{deploy_status}")
                
                if self.selected_method == 'batch':
                    enabled_count = sum(1 for cr in local_crs.values() if cr.get('enabled', True))
                    self.add_log_line(f"üöÄ Batch mode will apply {enabled_count} enabled CRs")
                elif self.selected_method == 'dry_run':
                    self.add_log_line("üîç Dry-run will validate CRs without applying")
            else:
                self.add_log_line(f"‚ùå No local {service_type} CRs found")
    
    def show_deployed_crs_for_delete_final(self, service_type, status_report):
        """Show final deployed CR list for delete"""
        service_map = {
            'vms': 'windowsvms',
            'mssql': 'mssqlservers',
            'otel': 'otelcollectors'
        }
        
        service_key = service_map.get(service_type)
        if service_key:
            service_data = status_report.get(service_key, {})
            deployed_crs = service_data.get('deployed_crs', {})
            
            if deployed_crs:
                self.add_log_line("‚ò∏Ô∏è Deployed CRs available for deletion:")
                for name, cr_data in deployed_crs.items():
                    status = cr_data.get('status', {}).get('phase', 'Unknown')
                    color_icon = 'üü¢' if status == 'Ready' else 'üü°' if status == 'Pending' else 'üî¥'
                    self.add_log_line(f"  {color_icon} {name} (status: {status})")
                
                if self.selected_method == 'graceful':
                    self.add_log_line("üîÑ Graceful shutdown will stop services cleanly first")
                elif self.selected_method == 'force':
                    self.add_log_line("‚ö†Ô∏è Force delete will immediately remove CRs")
            else:
                self.add_log_line(f"‚ùå No deployed {service_type} CRs found")
    
    def show_ansible_install_options(self, service_type, status_report):
        """Show Ansible install options"""
        self.add_log_line("üîß Ansible Playbook Installation:")
        self.add_log_line("  ‚Ä¢ Full automated provisioning")
        self.add_log_line("  ‚Ä¢ Dependency management")
        self.add_log_line("  ‚Ä¢ Network configuration")
        self.add_log_line("üí° Ready for Ansible execution")
    
    def show_manual_cr_generation(self, service_type, status_report):
        """Show manual CR generation options"""
        self.add_log_line("üìù Manual CR Generation Mode:")
        self.add_log_line("  ‚Ä¢ Generate CR files without applying")
        self.add_log_line("  ‚Ä¢ Review and modify before deployment")
        self.add_log_line("üí° Use 'Fix Issues' to generate missing CRs")
    
    def show_deployed_crs_for_uninstall(self, service_type, status_report):
        """Show deployed CRs for uninstall"""
        self.show_deployed_crs_for_delete_final(service_type, status_report)
    
    def show_ansible_cleanup_options(self, service_type, status_report):
        """Show Ansible cleanup options"""
        self.add_log_line("üîß Ansible Cleanup Process:")
        self.add_log_line("  ‚Ä¢ Full resource cleanup")
        self.add_log_line("  ‚Ä¢ Dependency removal")
        self.add_log_line("  ‚Ä¢ Network cleanup")
        self.add_log_line("üí° Comprehensive cleanup via Ansible")
    
    def show_cr_update_options(self, service_type, status_report):
        """Show CR update options"""
        self.add_log_line("üìù CR Update Mode (action: uninstall):")
        self.add_log_line("  ‚Ä¢ Modify local CRs to set action='uninstall'")
        self.add_log_line("  ‚Ä¢ Apply updated CRs to trigger uninstall")
        self.add_log_line("üí° Safer method that preserves configuration")
    
    def update_logs(self):
        """Update logs from the queue"""
        updated = False
        try:
            # Process multiple log entries at once
            for _ in range(5):
                log_line = log_queue.get_nowait()
                self.add_log_line(log_line)
                updated = True
        except queue.Empty:
            pass
        
        # Schedule next update
        if hasattr(self, 'loop') and self.loop:
            self.loop.set_alarm_in(0.3, lambda loop, user_data: self.update_logs())
            # Auto-refresh status every 5 seconds
            self.loop.set_alarm_in(5.0, lambda loop, user_data: self.auto_refresh_status())
    
    def auto_refresh_status(self):
        """Automatically refresh status display"""
        try:
            self.update_status_display()
            # Schedule next auto-refresh
            if hasattr(self, 'loop') and self.loop:
                self.loop.set_alarm_in(5.0, lambda loop, user_data: self.auto_refresh_status())
        except Exception as e:
            logger.warning(f"Auto-refresh failed: {e}")
    
    def initial_startup(self):
        """Perform initial startup tasks"""
        try:
            # Load initial status
            self.update_status_display()
            self.add_log_line("üìä Initial status display loaded")
            
            # Show startup summary
            status_report = self.service_manager.get_comprehensive_status()
            summary = status_report.get('summary', {})
            
            for service_type, service_summary in summary.items():
                local_count = service_summary.get('local_count', 0)
                deployed_count = service_summary.get('deployed_count', 0)
                self.add_log_line(f"üìà {service_type.upper()}: {local_count} local, {deployed_count} deployed")
                
        except Exception as e:
            self.add_log_line(f"‚ö†Ô∏è Error during startup: {e}")
    
    def execute_cr_install(self, service_type, service_name, cr_name, cr_data):
        """Execute CR installation directly"""
        self.add_log_line(f"üöÄ Installing {cr_name}...")
        
        try:
            # Apply the CR to Kubernetes
            self.add_log_line(f"üìù Applying Custom Resource...")
            
            # Import yaml here to avoid import issues
            import yaml
            
            # Load the actual CR file content instead of using service manager metadata
            import os
            cr_file_path = None
            
            # Try to find the CR file
            if 'file' in cr_data:
                # Service manager stores just the filename, need to construct full path
                filename = cr_data['file']
                cr_file_path = f"/root/kubernetes-installer/manifest-controller/{filename}"
            else:
                # Try common locations
                possible_paths = [
                    f"/root/kubernetes-installer/manifest-controller/{cr_name}-cr.yaml",
                    f"/root/kubernetes-installer/manifest-controller/{cr_name}.yaml"
                ]
                for path in possible_paths:
                    if os.path.exists(path):
                        cr_file_path = path
                        break
            
            if not cr_file_path or not os.path.exists(cr_file_path):
                self.add_log_line(f"‚ùå CR file not found for {cr_name}")
                return
                
            # Load the actual CR content from file
            import yaml
            with open(cr_file_path, 'r') as f:
                cr_data_copy = yaml.safe_load(f)
            
            # Ensure required fields are present and correct
            if not cr_data_copy:
                self.add_log_line(f"‚ùå Invalid CR file: {cr_file_path}")
                return
                
            # Add required Kubernetes fields if missing
            if 'apiVersion' not in cr_data_copy:
                cr_data_copy['apiVersion'] = 'infra.example.com/v1'
            
            if 'kind' not in cr_data_copy:
                # Map service_type to proper Kind
                kind_map = {
                    'vms': 'WindowsVM',
                    'mssql': 'MSSQLServer',
                    'otel': 'OTelCollector'
                }
                cr_data_copy['kind'] = kind_map.get(service_type, 'WindowsVM')
            
            if 'metadata' not in cr_data_copy:
                cr_data_copy['metadata'] = {}
            if 'name' not in cr_data_copy['metadata']:
                cr_data_copy['metadata']['name'] = cr_name
                
            # Set action to install in spec
            if 'spec' not in cr_data_copy:
                cr_data_copy['spec'] = {}
            cr_data_copy['spec']['action'] = 'install'
            
            # Create CR YAML content
            cr_yaml = yaml.dump(cr_data_copy, default_flow_style=False)
            
            # Write to temp file and apply
            import tempfile
            import os
            
            with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
                f.write(cr_yaml)
                temp_file = f.name
            
            try:
                # Apply CR using kubectl
                import subprocess
                result = subprocess.run(['kubectl', 'apply', '-f', temp_file], 
                                      capture_output=True, text=True)
                
                if result.returncode == 0:
                    self.add_log_line(f"‚úÖ Custom Resource applied successfully")
                    
                    # Run the corresponding playbook
                    playbook_map = {
                        'WindowsVM': 'windows-server-controller.yaml',
                        'MSSQLServer': 'mssql-install-tasks.yaml',
                        'OTelCollector': 'otel-install-tasks.yaml'
                    }
                    
                    # Use the CR kind from loaded data, not service_name parameter
                    cr_kind = cr_data_copy.get('kind', 'WindowsVM')
                    playbook = playbook_map.get(cr_kind)
                    self.add_log_line(f"üé≠ Looking for playbook for CR kind: {cr_kind}")
                    
                    if playbook:
                        playbook_path = f"/root/kubernetes-installer/{playbook}"
                        self.add_log_line(f"üé≠ Checking playbook path: {playbook_path}")
                        if os.path.exists(playbook_path):
                            self.add_log_line(f"üé≠ Running Windows VM installation playbook...")
                            
                            # Check for inventory file
                            inventory_path = "/root/kubernetes-installer/windows-inventory.yml"
                            ansible_cmd = ['ansible-playbook']
                            if os.path.exists(inventory_path):
                                ansible_cmd.extend(['-i', inventory_path])
                                self.add_log_line(f"üìã Using inventory: {inventory_path}")
                            else:
                                self.add_log_line(f"‚ö†Ô∏è No inventory file found, using localhost")
                            
                            # Add extra variables from the CR
                            cr_spec = cr_data_copy.get('spec', {})
                            action = cr_spec.get('action', 'install')
                            windows_version = cr_spec.get('windows_version', '2025')
                            vm_name = cr_spec.get('vmName', cr_name)
                            
                            # Pass required variables to ansible
                            ansible_cmd.extend([
                                '-e', f'action={action}',
                                '-e', f'windows_version={windows_version}',
                                '-e', f'vm_name={vm_name}',
                                '-e', f'cr_name={cr_name}'
                            ])
                            
                            ansible_cmd.append(playbook_path)
                            
                            self.add_log_line(f"üé≠ Running: {' '.join(ansible_cmd)}")
                            
                            playbook_result = subprocess.run(ansible_cmd, 
                                                          capture_output=True, text=True)
                            
                            if playbook_result.returncode == 0:
                                self.add_log_line(f"‚úÖ Windows VM installation completed successfully!")
                                self.add_log_line(f"üöÄ VM {cr_name} should now be deployed and running")
                            else:
                                self.add_log_line(f"‚ùå Playbook failed: {playbook_result.stderr}")
                                if playbook_result.stdout:
                                    self.add_log_line(f"üìã Playbook output: {playbook_result.stdout[-200:]}")
                        else:
                            self.add_log_line(f"‚ö†Ô∏è Playbook not found: {playbook_path}")
                    else:
                        self.add_log_line(f"‚ö†Ô∏è No playbook mapping for CR kind: {cr_kind}")
                    
                else:
                    self.add_log_line(f"‚ùå Failed to apply CR: {result.stderr}")
                    
            finally:
                # Clean up temp file
                if os.path.exists(temp_file):
                    os.unlink(temp_file)
                    
        except Exception as e:
            self.add_log_line(f"‚ùå Installation failed: {str(e)}")
        
        self.menu_state = 'main'

    def execute_cr_uninstall(self, service_type, service_name, cr_name, cr_data):
        """Execute CR uninstallation directly"""
        self.add_log_line(f"üóëÔ∏è Uninstalling {cr_name}...")
        
        try:
            # Get the full CR if available, otherwise reconstruct it
            if 'full_cr' in cr_data:
                full_cr = cr_data['full_cr'].copy()
            else:
                # Reconstruct CR from available data (for local CRs)
                full_cr = {
                    'apiVersion': 'infra.example.com/v1',
                    'kind': service_name,
                    'metadata': {
                        'name': cr_name,
                        'namespace': cr_data.get('namespace', 'default')
                    },
                    'spec': cr_data.get('spec', {})
                }
            
            # Update CR with uninstall action
            import yaml
            
            if 'spec' not in full_cr:
                full_cr['spec'] = {}
            full_cr['spec']['action'] = 'uninstall'
            
            # Apply updated CR to trigger uninstall
            import tempfile
            import os
            import subprocess
            
            cr_yaml = yaml.dump(full_cr, default_flow_style=False)
            
            with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
                f.write(cr_yaml)
                temp_file = f.name
            
            try:
                # Apply CR with uninstall action
                self.add_log_line(f"üìù Updating CR with uninstall action...")
                result = subprocess.run(['kubectl', 'apply', '-f', temp_file], 
                                      capture_output=True, text=True)
                
                if result.returncode == 0:
                    self.add_log_line(f"‚úÖ Custom Resource updated for uninstall")
                    
                    # Run uninstall playbook
                    playbook_map = {
                        'WindowsVM': 'k8s-redhat-kubernetes-uninstall-tasks.yaml',
                        'MSSQL': 'mssql-uninstall-tasks.yaml',
                        'OTel': 'otel-uninstall-tasks.yaml'
                    }
                    
                    playbook = playbook_map.get(service_name)
                    if playbook:
                        playbook_path = f"/root/kubernetes-installer/kubernetes/{playbook}"
                        if os.path.exists(playbook_path):
                            self.add_log_line(f"üé≠ Running uninstall playbook...")
                            result = subprocess.run(['ansible-playbook', playbook_path], 
                                                  capture_output=True, text=True)
                            
                            if result.returncode == 0:
                                self.add_log_line(f"‚úÖ Uninstall completed successfully!")
                            else:
                                self.add_log_line(f"‚ö†Ô∏è Playbook completed with warnings: {result.stderr}")
                        else:
                            self.add_log_line(f"‚ö†Ô∏è Playbook not found: {playbook_path}")
                            
                    # Optionally delete the CR completely
                    self.add_log_line(f"üóëÔ∏è Removing Custom Resource...")
                    cr_name = full_cr.get('metadata', {}).get('name', name)
                    cr_kind = full_cr.get('kind', service_name)
                    
                    # Map kind to proper kubectl resource type
                    resource_type_map = {
                        'WindowsVM': 'windowsvms',
                        'MSSQLServer': 'mssqlservers', 
                        'OTelCollector': 'otelcollectors'
                    }
                    resource_type = resource_type_map.get(cr_kind, cr_kind.lower())
                    
                    result = subprocess.run(['kubectl', 'delete', resource_type, cr_name], 
                                          capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        self.add_log_line(f"‚úÖ Custom Resource deleted")
                    else:
                        self.add_log_line(f"‚ö†Ô∏è CR deletion note: {result.stderr}")
                        
                else:
                    self.add_log_line(f"‚ùå Failed to update CR: {result.stderr}")
                    
            finally:
                # Clean up temp file
                if os.path.exists(temp_file):
                    os.unlink(temp_file)
                    
        except Exception as e:
            self.add_log_line(f"‚ùå Uninstallation failed: {str(e)}")
        
        self.menu_state = 'main'
    
    def execute_cr_apply(self, service_type, service_name, cr_name, cr_data):
        """Execute CR application directly"""
        self.add_log_line(f"üìù Applying {cr_name}...")
        
        try:
            # Apply the CR to Kubernetes
            self.add_log_line(f"üìù Applying Custom Resource to cluster...")
            
            # Import yaml here to avoid import issues
            import yaml
            
            # Load the actual CR file content instead of using service manager metadata
            import os
            cr_file_path = None
            
            # Try to find the CR file
            if 'file' in cr_data:
                # Service manager stores just the filename, need to construct full path
                filename = cr_data['file']
                cr_file_path = f"/root/kubernetes-installer/manifest-controller/{filename}"
            else:
                # Try common locations
                possible_paths = [
                    f"/root/kubernetes-installer/manifest-controller/{cr_name}-cr.yaml",
                    f"/root/kubernetes-installer/manifest-controller/{cr_name}.yaml"
                ]
                for path in possible_paths:
                    if os.path.exists(path):
                        cr_file_path = path
                        break
            
            if not cr_file_path or not os.path.exists(cr_file_path):
                self.add_log_line(f"‚ùå CR file not found for {cr_name}")
                return
                
            # Load the actual CR content from file
            import yaml
            with open(cr_file_path, 'r') as f:
                cr_data_copy = yaml.safe_load(f)
            
            # Ensure required fields are present and correct
            if not cr_data_copy:
                self.add_log_line(f"‚ùå Invalid CR file: {cr_file_path}")
                return
                
            # Add required Kubernetes fields if missing
            if 'apiVersion' not in cr_data_copy:
                cr_data_copy['apiVersion'] = 'infra.example.com/v1'
            
            if 'kind' not in cr_data_copy:
                # Map service_type to proper Kind
                kind_map = {
                    'vms': 'WindowsVM',
                    'mssql': 'MSSQLServer',
                    'otel': 'OTelCollector'
                }
                cr_data_copy['kind'] = kind_map.get(service_type, 'WindowsVM')
            
            if 'metadata' not in cr_data_copy:
                cr_data_copy['metadata'] = {}
            if 'name' not in cr_data_copy['metadata']:
                cr_data_copy['metadata']['name'] = cr_name
            
            # Create CR YAML content
            cr_yaml = yaml.dump(cr_data_copy, default_flow_style=False)
            
            # Write to temp file and apply
            import tempfile
            import os
            
            with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
                f.write(cr_yaml)
                temp_file = f.name
            
            try:
                # Apply CR using kubectl
                import subprocess
                result = subprocess.run(['kubectl', 'apply', '-f', temp_file], 
                                      capture_output=True, text=True)
                
                if result.returncode == 0:
                    self.add_log_line(f"‚úÖ Custom Resource applied successfully")
                    self.add_log_line(f"üí° CR {cr_name} is now deployed in the cluster")
                    
                    # Check if we should run a playbook based on the action
                    cr_action = cr_data_copy.get('spec', {}).get('action', 'unknown')
                    if cr_action == 'install':
                        # Run the corresponding installation playbook
                        playbook_map = {
                            'WindowsVM': 'windows-server-controller.yaml',
                            'MSSQLServer': 'mssql-install-tasks.yaml',
                            'OTelCollector': 'otel-install-tasks.yaml'
                        }
                        
                        cr_kind = cr_data_copy.get('kind', 'WindowsVM')
                        playbook = playbook_map.get(cr_kind)
                        if playbook:
                            playbook_path = f"/root/kubernetes-installer/{playbook}"
                            if os.path.exists(playbook_path):
                                self.add_log_line(f"üé≠ Running Windows VM installation playbook for {cr_action} action...")
                                
                                # Add extra variables from the CR
                                cr_spec = cr_data_copy.get('spec', {})
                                windows_version = cr_spec.get('windows_version', '2025')
                                vm_name = cr_spec.get('vmName', cr_name)
                                
                                # Build ansible command with variables
                                ansible_cmd = [
                                    'ansible-playbook',
                                    '-e', f'action={cr_action}',
                                    '-e', f'windows_version={windows_version}',
                                    '-e', f'vm_name={vm_name}',
                                    '-e', f'cr_name={cr_name}',
                                    playbook_path
                                ]
                                
                                playbook_result = subprocess.run(ansible_cmd, 
                                                              capture_output=True, text=True)
                                
                                if playbook_result.returncode == 0:
                                    self.add_log_line(f"‚úÖ Installation playbook completed successfully!")
                                    self.add_log_line(f"üöÄ VM {cr_name} should now be running")
                                else:
                                    self.add_log_line(f"‚ùå Playbook failed: {playbook_result.stderr}")
                                    if playbook_result.stdout:
                                        self.add_log_line(f"üìã Playbook output: {playbook_result.stdout[-200:]}")
                            else:
                                self.add_log_line(f"‚ö†Ô∏è Playbook not found: {playbook_path}")
                        else:
                            self.add_log_line(f"‚ö†Ô∏è No playbook mapping for {cr_kind}")
                    else:
                        self.add_log_line(f"üí° CR applied with action '{cr_action}' - no playbook execution needed")
                        
                else:
                    self.add_log_line(f"‚ùå Failed to apply CR: {result.stderr}")
                    
            finally:
                # Clean up temp file
                if os.path.exists(temp_file):
                    os.unlink(temp_file)
                    
        except Exception as e:
            self.add_log_line(f"‚ùå Application failed: {str(e)}")
        
        self.menu_state = 'main'
    
    def force_key_handler(self, key):
        """Forced key handler that logs everything and handles CR selection directly"""
        self.add_log_line(f"üîë FORCE_KEY: {key} - menu_state: {self.menu_state}")
        
        # Check if we have a popup open (regardless of menu_state)
        has_popup = hasattr(self, 'popup') and self.popup is not None
        
        if has_popup and key == '1':
            self.add_log_line("üî• FORCE: Number 1 pressed with popup open!")
            # Force close popup and trigger installation
            self.close_popup()
            self.add_log_line("üî• FORCE: Calling execute_cr_install directly!")
            # Call execute_cr_install directly with windows2025v3
            self.execute_cr_install('WindowsVM', 'Windows VMs', 'windows2025v3', {'action': 'install'})
            return
        
        # Handle ESC for any popup
        if has_popup and key == 'escape':
            self.add_log_line("üî• FORCE: ESC pressed - closing popup!")
            self.close_popup()
            return
        
        # Call the original handler
        return self.unhandled_input(key)

    def run(self):
        """Run the enhanced TUI"""
        self.loop = urwid.MainLoop(
            self.main_frame,
            self.palette,
            unhandled_input=self.force_key_handler,  # Use forced handler
            handle_mouse=True
        )
        
        # Welcome messages
        self.add_log_line("=== Windows Services Management System Started ===")
        self.add_log_line("üéØ Enhanced modular system with full functionality")
        self.add_log_line("üìä Consolidated VMs/Services view - no more VMs taking all space!")
        self.add_log_line("üîß Use F-keys for quick actions, Tab/arrows for navigation")
        self.add_log_line("‚ö° Monitoring WindowsVM, MSSQL, and OpenTelemetry resources")
        
        # Load initial status and start updates
        self.loop.set_alarm_in(0.2, lambda loop, user_data: self.initial_startup())
        self.loop.set_alarm_in(0.5, lambda loop, user_data: self.update_logs())
        
        try:
            self.loop.run()
        except KeyboardInterrupt:
            pass
        finally:
            logger.info("Enhanced TUI interface shutting down")
