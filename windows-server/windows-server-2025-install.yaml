



# Install Python requirements for Vault modules (must be first)
- name: Install Python requirements
  ansible.builtin.pip:
    requirements: "{{ playbook_dir }}/windows-server/requirements.txt"
    executable: pip3
    extra_args: --ignore-installed
  become: true
  tags: always


# Ensure port-forward script exists and is executable (must be before Vault usage)
- name: Ensure port-forward script exists and is executable
  ansible.builtin.stat:
    path: "{{ playbook_dir }}/library/start_portforward.sh"
  register: portforward_script_stat

- name: Fail if port-forward script is missing or not executable
  ansible.builtin.fail:
    msg: "Port-forward script is missing or not executable: {{ playbook_dir }}/library/start_portforward.sh"
  when: not portforward_script_stat.stat.exists or not portforward_script_stat.stat.mode|int is search('7')

- name: Port-forward Vault service for local access
  ansible.builtin.shell: |
    ./library/start_portforward.sh vault 8200 default /tmp/vault-portforward.log /tmp/vault-portforward.pid
    sleep 5
  async: 10
  poll: 0
  register: port_forward_job

- name: Show Vault port-forward log for troubleshooting
  ansible.builtin.shell: cat /tmp/vault-portforward.log || true
  register: vault_portforward_log
  changed_when: false
  ignore_errors: true
  tags: always

- name: Display Vault port-forward log output
  ansible.builtin.debug:
    var: vault_portforward_log.stdout
  tags: always

- name: Wait for Vault API to be reachable on localhost:8200
  ansible.builtin.wait_for:
    host: localhost
    port: 8200
    delay: 2
    timeout: 30
    state: started
  tags: always

# ...existing code continues as a flat list of tasks...


# Ensure port-forward script exists and is executable (must be before Vault usage)
- name: Ensure port-forward script exists and is executable
  ansible.builtin.stat:
    path: "{{ playbook_dir }}/library/start_portforward.sh"
  register: portforward_script_stat

- name: Fail if port-forward script is missing or not executable
  ansible.builtin.fail:
    msg: "Port-forward script is missing or not executable: {{ playbook_dir }}/library/start_portforward.sh"
  when: not portforward_script_stat.stat.exists or not portforward_script_stat.stat.mode|int is search('7')

- name: Port-forward Vault service for local access
  ansible.builtin.shell: |
    ./library/start_portforward.sh vault 8200 default /tmp/vault-portforward.log /tmp/vault-portforward.pid
    sleep 5
  async: 10
  poll: 0
  register: port_forward_job

- name: Show Vault port-forward log for troubleshooting
  ansible.builtin.shell: cat /tmp/vault-portforward.log || true
  register: vault_portforward_log
  changed_when: false
  ignore_errors: true
  tags: always

- name: Display Vault port-forward log output
  ansible.builtin.debug:
    var: vault_portforward_log.stdout
  tags: always

- name: Wait for Vault API to be reachable on localhost:8200
  ansible.builtin.wait_for:
    host: localhost
    port: 8200
    delay: 2
    timeout: 30
    state: started
  tags: always

# Set Vault environment variables for all Vault operations and CLI login (must come before any use)
- name: Set Vault environment variables for Ansible and CLI
  ansible.builtin.set_fact:
    vault_env:
      VAULT_ADDR: "http://localhost:8200"
      VAULT_TOKEN: "{{ lookup('pipe', 'jq -r .root_token /root/vault-init.json') }}"
    vault_addr: "http://localhost:8200"
    vault_token: "{{ lookup('pipe', 'jq -r .root_token /root/vault-init.json') }}"
  tags: always

# Ensure KV secrets engine is enabled at 'secret/'
- name: Ensure KV secrets engine is enabled at 'secret/'
  ansible.builtin.shell: |
    vault secrets enable -path=secret kv || vault secrets tune -max-lease-ttl=87600h secret/
  environment: "{{ vault_env }}"
  register: vault_kv_enable
  changed_when: "'successfully enabled' in vault_kv_enable.stdout or 'Success! Tuned the mount' in vault_kv_enable.stdout"
  failed_when: false
  tags: always

# Create Vault policy file for Windows Server 2025 admin secret (must come before any use)
- name: Write Vault policy file for win2025-admin-policy
  ansible.builtin.copy:
    dest: /tmp/win2025-admin-policy.hcl
    content: |
      path "secret/data/windows-server-2025/admin" {
        capabilities = ["create", "update", "read", "delete", "list"]
      }
  tags: always

# Apply the Vault policy for Windows Server 2025 admin secret
- name: Write win2025-admin-policy to Vault
  ansible.builtin.shell: |
    vault policy write win2025-admin-policy /tmp/win2025-admin-policy.hcl
  environment: "{{ vault_env }}"
  register: vault_policy_write_result
  changed_when: vault_policy_write_result.rc == 0
  failed_when: vault_policy_write_result.rc != 0
  tags: always

# Create a Vault token with the win2025-admin-policy
- name: Create Vault token with win2025-admin-policy
  ansible.builtin.shell: |
    vault token create -policy=win2025-admin-policy -format=json > /tmp/win2025-admin-token.json
  environment: "{{ vault_env }}"
  register: vault_token_create_result
  changed_when: vault_token_create_result.rc == 0
  failed_when: vault_token_create_result.rc != 0
  tags: always

# Read the created token value
- name: Read created Vault token value
  ansible.builtin.shell: jq -r .auth.client_token /tmp/win2025-admin-token.json
  register: win2025_admin_token
  changed_when: false
  tags: always

# Set Vault environment for admin token
- name: Set Vault environment for admin token
  ansible.builtin.set_fact:
    win2025_vault_env:
      VAULT_ADDR: "http://localhost:8200"

      VAULT_TOKEN: "{{ win2025_admin_token.stdout }}"
    win2025_admin_token: "{{ win2025_admin_token.stdout }}"
  tags: always

  # ...existing code continues as a flat list of tasks...

- name: Pre-flight checks
  block:
    - name: Check if Windows Server 2025 VHDX file exists
      ansible.builtin.stat:
        path: "{{ vhdx_path | default('./win2025server.vhdx') }}"
      register: vhdx_file_check

    - name: Download Windows Server 2025 VHDX if not present (with progress)
      progress_get_url:
        url: "{{ vhdx_download_url | default('https://go.microsoft.com/fwlink/?linkid=2293215&clcid=0x409&culture=en-us&country=us') }}"
        dest: "{{ vhdx_path | default('./win2025server.vhdx') }}"
        mode: '0644'
        timeout: 1800
      when: not vhdx_file_check.stat.exists
      register: vhdx_download_result

    - name: Re-check VHDX file after potential download
      ansible.builtin.stat:
        path: "{{ vhdx_path | default('./win2025server.vhdx') }}"
      register: vhdx_file_final_check
      failed_when: not vhdx_file_final_check.stat.exists

    - name: Display VHDX file information
      ansible.builtin.debug:
        msg:
          - "Windows Server 2025 VHDX found: {{ vhdx_path | default('./win2025server.vhdx') }}"
          - "Size: {{ (vhdx_file_final_check.stat.size / 1024 / 1024 / 1024) | round(2) }} GB"
          - "{{ 'Downloaded from Microsoft' if (vhdx_download_result is defined and vhdx_download_result.changed | default(false)) else 'Using existing local file' }}"

    - name: Ensure KubeVirt namespace exists
      kubernetes.core.k8s:
        api_version: v1
        kind: Namespace
        name: "{{ kubevirt_namespace }}"
        state: present

    - name: Check if KubeVirt is deployed and ready
      kubernetes.core.k8s_info:
        api_version: kubevirt.io/v1
        kind: KubeVirt
        name: kubevirt
        namespace: "{{ kubevirt_namespace }}"
      register: kubevirt_status
      failed_when:
        - kubevirt_status.resources | length == 0 or
          kubevirt_status.resources[0].status.phase != "Deployed"

    - name: Display KubeVirt status
      ansible.builtin.debug:
        msg: "✅ KubeVirt is ready: {{ kubevirt_status.resources[0].status.phase }}"

- name: Check for existing installation
  block:
    - name: Check if Windows Server VM already exists
      kubernetes.core.k8s_info:
        api_version: kubevirt.io/v1
        kind: VirtualMachine
        name: "{{ vm_name }}"
        namespace: "{{ kubevirt_namespace }}"
      register: existing_vm

    - name: Display existing installation warning
      ansible.builtin.debug:
        msg:
          - "⚠️  WARNING: Windows Server 2025 VM already exists!"
          - "Status: {{ existing_vm.resources[0].status.printableStatus | default('Unknown') }}"
          - "Proceeding with installation anyway - this may cause conflicts"
      when: existing_vm.resources | length > 0

- name: Storage preparation
  block:
    - name: Ensure qemu-img is installed
      ansible.builtin.package:
        name: qemu-img
        state: present

    - name: Ensure parted is installed (for partition table detection)
      ansible.builtin.package:
        name: parted
        state: present

    - name: Create base storage directory
      ansible.builtin.file:
        path: "{{ storage_dir }}"
        state: directory
        mode: '0755'

    - name: Check available disk space
      ansible.builtin.shell: |
        df -h {{ storage_dir }} | tail -1 | awk '{print $4}'
      register: available_space
      changed_when: false

    - name: Display storage information
      ansible.builtin.debug:
        msg:
          - "📁 Storage directory: {{ storage_dir }}"
          - "💾 Available space: {{ available_space.stdout }}"
          - "📊 VHDX file size: {{ (vhdx_file_final_check.stat.size / 1024 / 1024 / 1024) | round(2) }} GB"
          - "📊 Required space: ~{{ system_disk_size }} (system) + {{ installer_disk_size | default('12Gi') }} (installer request)"

    - name: Create directory structure for storage
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - "{{ storage_dir }}/win2025server-system-disk"
        - "{{ storage_dir }}/win2025server-installer"
        - "{{ storage_dir }}/win2025server-virtio-iso"

    - name: Convert Windows 2025 VHDX to system disk (RAW, direct boot)
      ansible.builtin.shell: |
        DST={{ storage_dir }}/win2025server-system-disk/disk.img
        SRC={{ vhdx_path | default('./win2025server.vhdx') }}
        ensure_raw() {
          # Return 0 if file is raw format; 1 otherwise
          [ -f "$1" ] || return 1
          fmt=$(qemu-img info --output=json "$1" 2>/dev/null | sed -n 's/.*"format": "\([^"]*\)".*/\1/p')
          [ "$fmt" = "raw" ]
        }
        if ensure_raw "$DST"; then
          echo "Bootable RAW system disk already present: $DST"
        else
          echo "Converting VHDX to RAW for direct boot (UEFI)"
          qemu-img convert -p -f vhdx -O raw "$SRC" "$DST"
          echo "Converted VHDX to RAW system disk: $DST"
        fi
      register: system_disk_result

  # No installer disk needed for direct boot from pre-installed VHDX

    - name: Detect partition table on converted system disk (GPT vs MBR)
      ansible.builtin.shell: |
        DST={{ storage_dir }}/win2025server-system-disk/disk.img
        if [ -f "$DST" ]; then
          part="$(parted -s "$DST" print 2>/dev/null | awk -F': ' '/Partition Table/ {print tolower($2)}')"
          if [ -z "$part" ]; then echo unknown; else echo "$part"; fi
        else
          echo missing
        fi
      args:
        executable: /bin/bash
      register: system_ptable
      changed_when: false

    - name: Set boot mode to UEFI (required for Windows 2025)
      ansible.builtin.set_fact:
        boot_mode: "uefi"

    - name: Compute VM bootloader structure (UEFI, no SecureBoot)
      ansible.builtin.set_fact:
        vm_bootloader_json: "{{ {'efi': {'secureBoot': False}} | to_json }}"

- name: Create unattended installation files
  block:
    - name: Create Install-VirtIO.ps1 script (used during setup and as fallback)
      ansible.builtin.copy:
        dest: "{{ storage_dir }}/Install-VirtIO.ps1"
        mode: '0644'
        content: |
          # Install VirtIO drivers for Windows Server 2025
          $ErrorActionPreference = 'Continue'
          $log = 'C:\\Windows\\Temp\\virtio-install.log'
          try { Start-Transcript -Path $log -Append -ErrorAction SilentlyContinue | Out-Null } catch {}

          function Get-VirtioRoot {
            # Prefer explicit D: mapping when available
            if (Test-Path 'D:\\NetKVM') { return 'D:\\' }
            $deadline = (Get-Date).AddMinutes(5)
            do {
              $vol = Get-WmiObject Win32_Volume |
                Where-Object { $_.DriveType -eq 5 -and ($_.Label -match 'virtio' -or $_.Label -match 'VIRTIO') } |
                Select-Object -First 1
              if ($vol -and $vol.DriveLetter) { return ($vol.DriveLetter + '\\') }
              foreach ($l in 'D'..'Z') {
                $root = "$l:\\"
                if (Test-Path (Join-Path $root 'NetKVM')) { return $root }
              }
              Start-Sleep -Seconds 5
            } while ((Get-Date) -lt $deadline)
            return $null
          }

          $root = Get-VirtioRoot
          if (-not $root) {
            Write-Host 'VirtIO ISO not found.'
          } else {
            Write-Host "Using VirtIO root: $root"
            # Prefer NetKVM first to enable networking (2k25 only)
            $nkCandidates = @(
              (Join-Path $root 'NetKVM\2k25\amd64\netkvm.inf')
            )
            foreach ($nk in $nkCandidates) {
              if (Test-Path $nk) {
                Write-Host "Installing NetKVM from $nk"
                pnputil /add-driver "$nk" /install
                if ($LASTEXITCODE -ne 0) { Write-Host "pnputil returned $LASTEXITCODE for NetKVM" }
                break
              }
            }

            # Install a curated set of VirtIO drivers using pnputil; fall back to DISM recurse
            $driverDirs = @('vioscsi','viostor','Balloon','vioinput','viorng','pvpanic','qxl','qxldod','vioserial','NetKVM','viogpu','viofs','viosock')
            foreach ($d in $driverDirs) {
              $paths = @(
                (Join-Path $root ($d + '\\2k25\\amd64'))
              )
              foreach ($p in $paths) {
                if (Test-Path $p) {
                  Write-Host "Installing drivers from $p"
                  pnputil /add-driver (Join-Path $p '*.inf') /subdirs /install
                  break
                }
              }
            }

            # Final sweep with DISM in case anything was missed
            Write-Host "Final DISM sweep under $root"
            & dism.exe /online /add-driver /driver:"$root" /recurse
          }
          try { pnputil /scan-devices } catch {}
          try { Stop-Transcript } catch {}

    - name: Create SetupComplete.cmd (fallback to ensure drivers installation runs at end of setup)
      ansible.builtin.copy:
        dest: "{{ storage_dir }}/SetupComplete.cmd"
        mode: '0644'
        content: |
          @echo off
          REM Ensure target folder exists
          if not exist C:\\Windows\\Setup\\Scripts mkdir C:\\Windows\\Setup\\Scripts
          REM Copy script locally for reliability
          if not exist C:\\Windows\\Temp\\Install-VirtIO.ps1 (
            for %%%%L in (D E F G H I J K L M N O P Q R S T U V W X Y Z) do (
              if exist %%%%L:\\Install-VirtIO.ps1 (
                copy /Y %%%%L:\\Install-VirtIO.ps1 C:\\Windows\\Temp\\Install-VirtIO.ps1
                goto :copied
              )
            )
          )
          :copied
          powershell -NoProfile -ExecutionPolicy Bypass -File C:\\Windows\\Temp\\Install-VirtIO.ps1

    - name: Create Autounattend.xml for automated installation
      ansible.builtin.copy:
        dest: "{{ storage_dir }}/Autounattend.xml"
        mode: '0644'
        content: |
          <?xml version="1.0" encoding="utf-8"?>
          <unattend xmlns="urn:schemas-microsoft-com:unattend">
            <settings pass="windowsPE">
              <component xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State"
                         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                         name="Microsoft-Windows-International-Core-WinPE"
                         processorArchitecture="amd64"
                         publicKeyToken="31bf3856ad364e35"
                         language="neutral"
                         versionScope="nonSxS">
                <SetupUILanguage>
                  <UILanguage>en-US</UILanguage>
                </SetupUILanguage>
                <InputLocale>en-US</InputLocale>
                <SystemLocale>en-US</SystemLocale>
                <UILanguage>en-US</UILanguage>
                <UserLocale>en-US</UserLocale>
              </component>
              <component xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State"
                         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                         name="Microsoft-Windows-Setup"
                         processorArchitecture="amd64"
                         publicKeyToken="31bf3856ad364e35"
                         language="neutral"
                         versionScope="nonSxS">
                <DiskConfiguration>
                  <Disk wcm:action="add">
                    <CreatePartitions>
                      <CreatePartition wcm:action="add">
                        <Order>1</Order>
                        <Type>Primary</Type>
                        <Extend>true</Extend>
                      </CreatePartition>
                    </CreatePartitions>
                    <ModifyPartitions>
                      <ModifyPartition wcm:action="add">
                        <Active>true</Active>
                        <Format>NTFS</Format>
                        <Label>Windows</Label>
                        <Order>1</Order>
                        <PartitionID>1</PartitionID>
                      </ModifyPartition>
                    </ModifyPartitions>
                    <DiskID>1</DiskID>
                    <WillWipeDisk>true</WillWipeDisk>
                  </Disk>
                </DiskConfiguration>
                <ImageInstall>
                  <OSImage>
                    <InstallTo>
                      <DiskID>1</DiskID>
                      <PartitionID>1</PartitionID>
                    </InstallTo>
                  </OSImage>
                </ImageInstall>
                <UserData>
                  <AcceptEula>true</AcceptEula>
                  <FullName>Administrator</FullName>
                  <Organization></Organization>
                  {% if windows_product_key %}
                  <ProductKey>
                    <Key>{{ windows_product_key }}</Key>
                  </ProductKey>
                  {% endif %}
                </UserData>
                <DriverPaths>
                  <PathAndCredentials wcm:action="add" wcm:keyValue="1">
                    <Path>D:\viostor\2k25\amd64</Path>
                  </PathAndCredentials>
                  <PathAndCredentials wcm:action="add" wcm:keyValue="2">
                    <Path>D:\NetKVM\2k25\amd64</Path>
                  </PathAndCredentials>
                  <PathAndCredentials wcm:action="add" wcm:keyValue="3">
                    <Path>D:\Balloon\2k25\amd64</Path>
                  </PathAndCredentials>
                  <PathAndCredentials wcm:action="add" wcm:keyValue="4">
                    <Path>D:\vioscsi\2k25\amd64</Path>
                  </PathAndCredentials>
                </DriverPaths>
              </component>
            </settings>
            <settings pass="specialize">
              <component xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State"
                         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                         name="Microsoft-Windows-Shell-Setup"
                         processorArchitecture="amd64"
                         publicKeyToken="31bf3856ad364e35"
                         language="neutral"
                         versionScope="nonSxS">
                <ComputerName>WIN2025-SERVER</ComputerName>
                <CopyProfile>false</CopyProfile>
              </component>
            </settings>
            <settings pass="oobeSystem">
              <component xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State"
                         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                         name="Microsoft-Windows-International-Core"
                         processorArchitecture="amd64"
                         publicKeyToken="31bf3856ad364e35"
                         language="neutral"
                         versionScope="nonSxS">
                <InputLocale>en-US</InputLocale>
                <SystemLocale>en-US</SystemLocale>
                <UILanguage>en-US</UILanguage>
                <UserLocale>en-US</UserLocale>
              </component>
              <component xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State"
                         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                         name="Microsoft-Windows-Shell-Setup"
                         processorArchitecture="amd64"
                         publicKeyToken="31bf3856ad364e35"
                         language="neutral"
                         versionScope="nonSxS">
                <TimeZone>UTC</TimeZone>
                <UserAccounts>
                  <AdministratorPassword>
                    <Value>{{ windows_admin_password }}</Value>
                    <PlainText>true</PlainText>
                  </AdministratorPassword>
                </UserAccounts>
                <AutoLogon>
                  <Enabled>true</Enabled>
                  <LogonCount>3</LogonCount>
                  <Domain>.</Domain>
                  <Username>Administrator</Username>
                  <Password>
                    <Value>{{ windows_admin_password }}</Value>
                    <PlainText>true</PlainText>
                  </Password>
                </AutoLogon>
                <OOBE>
                  <HideEULAPage>true</HideEULAPage>
                  <HideLocalAccountScreen>true</HideLocalAccountScreen>
                  <HideOEMRegistrationScreen>true</HideOEMRegistrationScreen>
                  <HideOnlineAccountScreens>true</HideOnlineAccountScreens>
                  <HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
                  <NetworkLocation>Work</NetworkLocation>
                  <ProtectYourPC>1</ProtectYourPC>
                </OOBE>
                <FirstLogonCommands>
                  <SynchronousCommand wcm:action="add">
                    <Order>1</Order>
                    <Description>Run VirtIO installer script from any CD-ROM</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>cmd /c for %%%%L in (D E F G H I J K L M N O P Q R S T U V W X Y Z) do (if exist %%%%L:\\Install-VirtIO.ps1 (copy /Y %%%%L:\\Install-VirtIO.ps1 C:\\Windows\\Temp\\Install-VirtIO.ps1 &amp; powershell -NoProfile -ExecutionPolicy Bypass -File C:\\Windows\\Temp\\Install-VirtIO.ps1 &amp; goto :done_inst)) &amp; :done_inst</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>2</Order>
                    <Description>Install VirtIO NetKVM Driver</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>cmd /c if exist D:\\NetKVM\\2k25\\amd64\\netkvm.inf (echo Installing NetKVM from D:\\NetKVM\\2k25\\amd64\\netkvm.inf &amp; pnputil /add-driver D:\\NetKVM\\2k25\\amd64\\netkvm.inf /install &amp; pnputil /scan-devices)</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>3</Order>
                    <Description>Install VirtIO RNG (viorng)</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>cmd /c if exist D:\\viorng\\2k25\\amd64\\viorng.inf (pnputil /add-driver D:\\viorng\\2k25\\amd64\\viorng.inf /install)</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>4</Order>
                    <Description>Install VirtIO Balloon Driver</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>cmd /c if exist D:\\Balloon\\2k25\\amd64\\balloon.inf (pnputil /add-driver D:\\Balloon\\2k25\\amd64\\balloon.inf /install)</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>5</Order>
                    <Description>Install VirtIO Serial Driver</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>cmd /c if exist D:\\vioserial\\2k25\\amd64\\vioser.inf (pnputil /add-driver D:\\vioserial\\2k25\\amd64\\vioser.inf /install)</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>6</Order>
                    <Description>Install VirtIO SCSI Driver</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>cmd /c if exist D:\\vioscsi\\2k25\\amd64\\vioscsi.inf (pnputil /add-driver D:\\vioscsi\\2k25\\amd64\\vioscsi.inf /install)</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>7</Order>
                    <Description>Install VirtIO Input (Tablet/HID) Driver</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>cmd /c if exist D:\\vioinput\\2k25\\amd64\\vioinput.inf (pnputil /add-driver D:\\vioinput\\2k25\\amd64\\vioinput.inf /install)</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>8</Order>
                    <Description>Install VirtIO GPU DOD Driver</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>cmd /c if exist D:\\viogpu\\2k25\\amd64\\viogpudo.inf (pnputil /add-driver D:\\viogpu\\2k25\\amd64\\viogpudo.inf /install)</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>9</Order>
                    <Description>Install Remaining VirtIO Drivers (bulk)</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>cmd /c if exist D:\\ (for %%%%D in (viostor viofs viosock qxl pvpanic viorng vioserial) do if exist D:\\%%%%D\\2k25\\amd64\\*.inf pnputil /add-driver D:\\%%%%D\\2k25\\amd64\\*.inf /install)</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>10</Order>
                    <Description>Enable Remote Desktop</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>11</Order>
                    <Description>Allow RDP through firewall</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>netsh advfirewall firewall set rule group="remote desktop" new enable=Yes</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>12</Order>
                    <Description>Enable WinRM</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>winrm quickconfig -quiet</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>13</Order>
                    <Description>Allow WinRM unencrypted and basic auth</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>powershell -Command "winrm set winrm/config/service '@{AllowUnencrypted=\"true\"}'; winrm set winrm/config/service/auth '@{Basic=\"true\"}'; winrm set winrm/config/client '@{TrustedHosts=\"*\"}'; Enable-PSRemoting -Force -SkipNetworkProfileCheck; New-NetFirewallRule -DisplayName 'Allow RDP' -Direction Inbound -Protocol TCP -LocalPort 3389 -Action Allow -Profile Domain,Private,Public; New-NetFirewallRule -DisplayName 'Allow WinRM HTTP' -Direction Inbound -Protocol TCP -LocalPort 5985 -Action Allow -Profile Domain,Private,Public; New-NetFirewallRule -DisplayName 'Allow WinRM HTTPS' -Direction Inbound -Protocol TCP -LocalPort 5986 -Action Allow -Profile Domain,Private,Public"</CommandLine>
                  </SynchronousCommand>
                  <SynchronousCommand wcm:action="add">
                    <Order>14</Order>
                    <Description>Setup WinRM HTTPS with self-signed certificate</Description>
                    <RequiresUserInput>false</RequiresUserInput>
                    <CommandLine>powershell -Command "$cert = New-SelfSignedCertificate -DnsName 'localhost','127.0.0.1' -CertStoreLocation 'cert:\\LocalMachine\\My'; try { Get-WSManInstance -ResourceURI winrm/config/Listener | Where-Object {$_.Transport -eq 'HTTPS'} | Remove-WSManInstance -Force } catch { Write-Host 'No existing HTTPS listeners' }; New-WSManInstance -ResourceURI winrm/config/Listener -SelectorSet @{Address='*';Transport='HTTPS'} -ValueSet @{Hostname='localhost';CertificateThumbprint=$cert.Thumbprint}; Restart-Service WinRM"</CommandLine>
                  </SynchronousCommand>
                </FirstLogonCommands>
              </component>
            </settings>
          </unattend>

    - name: Load Autounattend.xml content
      ansible.builtin.slurp:
        src: "{{ storage_dir }}/Autounattend.xml"
      register: unattend_slurped

    - name: Load Install-VirtIO.ps1 content
      ansible.builtin.slurp:
        src: "{{ storage_dir }}/Install-VirtIO.ps1"
      register: install_ps1_slurped

    - name: Load SetupComplete.cmd content
      ansible.builtin.slurp:
        src: "{{ storage_dir }}/SetupComplete.cmd"
      register: setupcomplete_slurped

    - name: Set default VirtIO ISO download URL when not provided
      ansible.builtin.set_fact:
        virtio_iso_download_url: "{{ virtio_iso_url | default('https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/latest-virtio/virtio-win.iso') }}"

    - name: Check if VirtIO ISO already exists in playbook directory
      ansible.builtin.stat:
        path: "./virtio-win.iso"
      register: virtio_iso_local_exists

    - name: Check if VirtIO ISO already exists in storage directory
      ansible.builtin.stat:
        path: "{{ storage_dir }}/win2025server-virtio-iso/disk.img"
      register: virtio_iso_storage_exists

    - name: Download VirtIO driver ISO to playbook directory if not exists locally (with progress)
      progress_get_url:
        url: "{{ virtio_iso_download_url }}"
        dest: "./virtio-win.iso"
        mode: '0644'
        timeout: 1800
      when:
        - virtio_iso_path is not defined
        - not virtio_iso_local_exists.stat.exists
      register: virtio_iso_download_result

    - name: Copy VirtIO ISO from playbook directory to storage directory (always overwrite)
      ansible.builtin.copy:
        src: "./virtio-win.iso"
        dest: "{{ storage_dir }}/win2025server-virtio-iso/disk.img"
        mode: '0644'
        force: yes
      when:
        - virtio_iso_path is not defined
        - virtio_iso_local_exists.stat.exists or (virtio_iso_download_result is defined and virtio_iso_download_result.changed)
      register: virtio_iso_copy_to_storage

    - name: Display VirtIO ISO download status
      ansible.builtin.debug:
        msg: |
          {% if virtio_iso_download_result is defined and virtio_iso_download_result.changed %}
          Downloaded VirtIO ISO from {{ virtio_iso_download_url }} to ./virtio-win.iso
          {% elif virtio_iso_copy_to_storage is defined and virtio_iso_copy_to_storage.changed %}
          Copied existing VirtIO ISO from ./virtio-win.iso to storage directory
          {% else %}
          Using existing VirtIO ISO in storage directory
          {% endif %}
      when: virtio_iso_path is not defined

    - name: Copy VirtIO driver ISO from custom path (always overwrite)
      ansible.builtin.copy:
        src: "{{ virtio_iso_path }}"
        dest: "{{ storage_dir }}/win2025server-virtio-iso/disk.img"
        mode: '0644'
        force: yes
      when:
        - virtio_iso_path is defined
      register: virtio_iso_copy_result

    - name: Display VirtIO ISO copy status
      ansible.builtin.debug:
        msg: "{{ 'Copied VirtIO ISO from ' + virtio_iso_path if (virtio_iso_copy_result is defined and virtio_iso_copy_result.changed) else 'Using existing local VirtIO ISO at ' + storage_dir + '/win2025server-virtio-iso/disk.img' }}"
      when: virtio_iso_path is defined

    - name: Create Sysprep Secret with unattend files
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: win2025server-sysprep
            namespace: "{{ kubevirt_namespace }}"
          type: Opaque
          data:
            Autounattend.xml: "{{ unattend_slurped.content }}"
            Unattend.xml: "{{ unattend_slurped.content }}"
            unattend.xml: "{{ unattend_slurped.content }}"
            Install-VirtIO.ps1: "{{ install_ps1_slurped.content }}"
            SetupComplete.cmd: "{{ setupcomplete_slurped.content }}"
            startup.nsh: "{{ ('echo -off\n' ~
              'fs0:\\EFI\\Microsoft\\Boot\\bootmgfw.efi\n' ~
              'fs0:\\EFI\\BOOT\\BOOTX64.EFI\n' ~
              'fs1:\\EFI\\Microsoft\\Boot\\bootmgfw.efi\n' ~
              'fs1:\\EFI\\BOOT\\BOOTX64.EFI\n' ~
              'fs2:\\EFI\\Microsoft\\Boot\\bootmgfw.efi\n' ~
              'fs2:\\EFI\\BOOT\\BOOTX64.EFI\n' ~
              'fs3:\\EFI\\Microsoft\\Boot\\bootmgfw.efi\n' ~
              'fs3:\\EFI\\BOOT\\BOOTX64.EFI\n') | b64encode }}"

    - name: Display unattend configuration
      ansible.builtin.debug:
        msg:
          - "📋 Unattend.xml Configuration:"
          - "  - Administrator Password: {{ windows_admin_password }}"
          - "  - Sysprep Secret: win2025server-sysprep (Autounattend.xml)"

- name: Create Kubernetes storage resources
  block:
    - name: Create local storage class
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: storage.k8s.io/v1
          kind: StorageClass
          metadata:
            name: local-storage
          provisioner: kubernetes.io/no-provisioner
          volumeBindingMode: WaitForFirstConsumer
          reclaimPolicy: Retain

    - name: Get node hostname for affinity
      ansible.builtin.shell: kubectl get nodes -o jsonpath='{.items[0].metadata.name}'
      register: node_hostname
      changed_when: false

    - name: Create PersistentVolumes
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: PersistentVolume
          metadata:
            name: "{{ item.name }}"
            labels:
              type: local
              app: win2025server
          spec:
            capacity:
              storage: "{{ item.size }}"
            accessModes: "{{ item.access_modes }}"
            persistentVolumeReclaimPolicy: Retain
            storageClassName: local-storage
            volumeMode: Filesystem
            hostPath:
              path: "{{ storage_dir }}/{{ item.path }}"
              type: Directory
            nodeAffinity:
              required:
                nodeSelectorTerms:
                - matchExpressions:
                  - key: kubernetes.io/hostname
                    operator: In
                    values: ["{{ node_hostname.stdout }}"]
      loop:
        - { name: "win2025server-installer-pv", size: "15Gi", access_modes: ["ReadWriteOnce"], path: "win2025server-installer" }
        - { name: "win2025server-system-pv", size: "64Gi", access_modes: ["ReadWriteOnce"], path: "win2025server-system-disk" }
        - { name: "win2025server-virtio-iso-pv", size: "{{ virtio_iso_size | default('1Gi') }}", access_modes: ["ReadOnlyMany"], path: "win2025server-virtio-iso" }

    - name: Create PersistentVolumeClaims
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: "{{ item.name }}"
            namespace: "{{ kubevirt_namespace }}"
          spec:
            accessModes: "{{ item.access_modes }}"
            resources:
              requests:
                storage: "{{ item.size }}"
            storageClassName: local-storage
            volumeMode: Filesystem
      loop:
        - { name: "win2025server-installer-pvc", size: "15Gi", access_modes: ["ReadWriteOnce"] }
        - { name: "win2025server-system-pvc", size: "64Gi", access_modes: ["ReadWriteOnce"] }
        - { name: "win2025server-virtio-iso-pvc", size: "{{ virtio_iso_size | default('1Gi') }}", access_modes: ["ReadOnlyMany"] }

- name: Deploy Windows Server VM
  block:
    - name: Build VirtualMachine definition (UEFI, direct boot from QCOW2 system disk)
      ansible.builtin.set_fact:
        vm_definition:
          apiVersion: kubevirt.io/v1
          kind: VirtualMachine
          metadata:
            name: "{{ vm_name }}"
            namespace: "{{ kubevirt_namespace }}"
            labels:
              app: win2025server
              os: windows
              version: "2025"
          spec:
            runStrategy: RerunOnFailure
            template:
              metadata:
                labels:
                  kubevirt.io/vm: "{{ vm_name }}"
                  os: windows
                  version: "2025"
              spec:
                domain:
                  cpu:
                    cores: "{{ vm_cpu_cores | int }}"
                    model: "host-passthrough"
                  resources:
                    requests:
                      memory: "{{ vm_memory }}"
                  memory:
                    guest: "{{ vm_memory }}"
                  machine:
                    type: q35
                  firmware:
                    bootloader:
                      efi:
                        secureBoot: false
                    smm:
                      enabled: true
                  features:
                    acpi: {}
                    apic: {}
                    hyperv:
                      relaxed: {}
                      vapic: {}
                      spinlocks:
                        retries: 8191
                      synic: {}
                      synictimer:
                        direct: {}
                      vpindex: {}
                      runtime: {}
                      reset: {}
                      freqs: {}
                      reenlightenment: {}
                      tscFrequency: {}
                      tlbflush: {}
                      ipi: {}
                  clock:
                    timezone: UTC
                    timer:
                      hpet:
                        present: false
                      pit:
                        tickPolicy: delay
                      rtc:
                        tickPolicy: catchup
                      hyperv:
                        present: true
                  devices:
                    bootMenu:
                      enabled: true
                    autoattachPodInterface: false
                    autoattachSerialConsole: true
                    autoattachGraphicsDevice: true
                    rng: {}
                    disks:
                      - name: disk0
                        disk:
                          bus: sata
                        bootOrder: 1
                      - name: virtio-iso
                        cdrom:
                          bus: sata
                        bootOrder: 3
                      - name: sysprep
                        cdrom:
                          bus: sata
                        bootOrder: 2
                    interfaces:
                      - name: default
                        masquerade: {}
                        model: virtio
                    inputs:
                      - type: tablet
                        bus: usb
                        name: tablet
                    video:
                      - name: video0
                        device:
                          name: virtio
                networks:
                  - name: default
                    pod: {}
                volumes:
                  - name: disk0
                    persistentVolumeClaim:
                      claimName: "{{ vm_name }}-system-pvc"
                  - name: virtio-iso
                    persistentVolumeClaim:
                      claimName: "{{ vm_name }}-virtio-iso-pvc"
                  - name: sysprep
                    sysprep:
                      secret:
                        name: win2025server-sysprep

    - name: Fix cores to be integer type (no change, kept for compatibility)
      ansible.builtin.set_fact:
        vm_definition: "{{ vm_definition | combine({'spec': {'template': {'spec': {'domain': {'cpu': {'cores': vm_cpu_cores | int}}}}}}, recursive=True) }}"

    - name: Create Windows Server 2025 VirtualMachine
      kubernetes.core.k8s:
        definition: "{{ vm_definition }}"
        state: present
        wait: false
      register: vm_creation_result

    - name: Create VNC access service
      tags: [access_services]
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: win2025server-vnc
            namespace: "{{ kubevirt_namespace }}"
            labels:
              app: win2025server
          spec:
            type: NodePort
            selector:
              kubevirt.io/vm: "{{ vm_name }}"
            ports:
              - name: vnc
                port: 5900
                targetPort: 5900
                protocol: TCP
                nodePort: 30001

    - name: Create WinRM access service
      tags: [access_services]
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: win2025server-winrm
            namespace: "{{ kubevirt_namespace }}"
            labels:
              app: win2025server
          spec:
            type: ClusterIP
            selector:
              kubevirt.io/vm: "{{ vm_name }}"
            ports:
              - name: winrm
                port: 5985
                targetPort: 5985
                protocol: TCP

    - name: Create WinRM HTTPS access service
      tags: [access_services]
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: win2025server-winrm-https
            namespace: "{{ kubevirt_namespace }}"
            labels:
              app: win2025server
          spec:
            type: ClusterIP
            selector:
              kubevirt.io/vm: "{{ vm_name }}"
            ports:
              - name: winrm-https
                port: 5986
                targetPort: 5986
                protocol: TCP

    - name: Create RDP access service
      tags: [access_services]
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: win2025server-rdp
            namespace: "{{ kubevirt_namespace }}"
            labels:
              app: win2025server
          spec:
            type: NodePort
            selector:
              kubevirt.io/vm: "{{ vm_name }}"
            ports:
              - name: rdp
                port: 3389
                targetPort: 3389
                protocol: TCP
                nodePort: 30002
 
    - name: Verify installation
      block:
        - name: Wait for VM to be created
          kubernetes.core.k8s_info:
            api_version: kubevirt.io/v1
            kind: VirtualMachine
            namespace: "{{ kubevirt_namespace }}"
          register: deployed_vm
          until: deployed_vm.resources | length > 0
          retries: 10

        - name: Wait for VM to start
          kubernetes.core.k8s_info:
            api_version: kubevirt.io/v1
            kind: VirtualMachineInstance
            name: "{{ vm_name }}"
            namespace: "{{ kubevirt_namespace }}"
          register: vmi_status
          until:
            - vmi_status.resources | length > 0
            - vmi_status.resources[0].status.phase in ["Running", "Scheduled"]
          retries: 30
          delay: 10
          

        - name: Display installation results
          ansible.builtin.debug:
            msg:
              - "🎉 Windows Server 2025 VM Installation Complete!"
              - ""
              - "📊 Status Information:"
              - "  VM Status: {{ deployed_vm.resources[0].status.printableStatus | default('Created') }}"
              - "  VMI Phase: {{ vmi_status.resources[0].status.phase | default('Pending') }}"
              - "  Node: {{ vmi_status.resources[0].status.nodeName | default('Not assigned') }}"
              - "  IP: {{ vmi_status.resources[0].status.interfaces[0].ipAddress | default('Not assigned') }}"
              - ""
              - "🔐 Access Information:"
              - "  Administrator password is securely stored in HashiCorp Vault."
              - "  Retrieve with:"
              - "    vault kv get -field=password secret/windows-server-2025/admin"
              - "  (Requires VAULT_ADDR and VAULT_TOKEN to be set)"
              - ""
              - "🖥️  VNC Access:"
              - "  Direct: virtctl vnc {{ vm_name }} -n {{ kubevirt_namespace }}"
              - "  Proxy: virtctl vnc {{ vm_name }} -n {{ kubevirt_namespace }} --proxy-only --port 5900"
              - "  NodePort: localhost:30001 (if NodePort allowed through firewall)"
              - ""
              - "�️  RDP Access (after Windows setup completes):"
              - "  Method 1 - Port Forward: kubectl -n {{ kubevirt_namespace }} port-forward service/{{ vm_name }}-vnc 3389:3389"
              - "  Method 2 - VM IP Direct: RDP to {{ vmi_status.resources[0].status.interfaces[0].ipAddress | default('VM_IP') }}:3389"
              - "  Method 3 - virtctl: virtctl port-forward {{ vm_name }} -n {{ kubevirt_namespace }} 3389:3389"
              - "  Then connect RDP client to: localhost:3389"
              - ""
              - "🛠️  Console Access:"
              - "  Serial: virtctl console {{ vm_name }} -n {{ kubevirt_namespace }}"
              - ""
              - "�📁 Storage Configuration:"
              - "  Installer VHDX: {{ storage_dir }}/win2025server-installer/disk.img (boot)"
              - "  System Disk: {{ storage_dir }}/win2025server-system-disk/disk.img (blank {{ system_disk_size }})"
              - "  VirtIO ISO: {{ storage_dir }}/win2025server-virtio-iso/disk.img"
              - "  Sysprep: Secret win2025server-sysprep (Autounattend.xml)"
              - ""
              - "🛠 Next Steps:"
              - "1. Use VNC to monitor Windows installation progress"
              - "2. Installation proceeds automatically with unattend.xml"
              - "3. After Windows setup completes, use RDP for remote access"
              - "4. Login with Administrator (password from Vault)"